\section{Ansatz selection and construction}\label{sec:Ansatz}

Ansatz selection is a central part of the VQE pipeline. The right choice of ansatz is critical to obtain a final solution that is close to the true state of interest. To achieve this, it is essential to maximize the span of the ansatz in parts of the Hilbert space that contain the solution (i.e., a state that is sufficiently close to the desired state which globally minimizes the expectation value of the Hamiltonian). The span of possible states an ansatz can reach is referred to as its expressibility. However, performing a variational optimization on an ansatz with high expressibility could easily become intractable due to the number of parameters required to allow reaching many these different states, the number of iterations required for convergence, or the number of shots required to achieve sufficient gradient accuracy to continue the optimization. Whether an ansatz can be optimized in a tractable manner is referred to as its trainability. In practice, it is better to choose an ansatz spanning a smaller subspace, but remaining trainable. Designing an efficient ansatz for a given number of qubits hence involves finding an optimal trade-off between expressibility and trainability.

\paragraph{Expressibility:} The expressibility of an ansatz describes its span across the unitary space of accessible states \cite{Sim2019, Holmes2021, Nakaji2021}.
One can quantify the expressibility of an ansatz by assessing the distance between the distributions of the unitaries that can be generated by the ansatz, and the uniform distribution of unitaries in the corresponding Hilbert space \cite{Sim2019}, also known as the Haar measure. A given ansatz is called a t-design if it is indistinguishable from the Haar measure up to the $t^{th}$ moment. A 2-design ansatz can produce any possible state in the Hilbert space considered, from any input state: it is maximally expressive. As a side note, Hubregtsen et al. \cite{Hubregtsen2021} also study the relationship between the expressibility of quantum neural networks and their accuracy in a classification task. 

More formally, one can define as $\mathbb{U}$ the set of unitaries accessible by an ansatz, and $\mathcal{U}(N)$ the complete unitary group in which the ansatz is expressed (with $N$ the number of qubits it spans), such that $\mathbb{U} \subseteq \mathcal{U}(N)$ \cite{Sim2019, Cerezo2021_BP, Holmes2021, Nakaji2021}.
The following super operator, representing the second order difference between the Haar measure on $\mathcal{U}(N)$ and the uniformity distribution of $\mathbb{U}$ can be constructed (we follow the formalism in \cite{Holmes2021}):
\begin{align} \label{eq:expressibility_integral}
    \mathcal{A_{\mathbb{U}}}(\cdot) := \int_{\mathcal{U}(n)} d_{\mu}(V)& V^{\otimes 2}(\cdot)(V^{\dagger})^{\otimes 2} \nonumber \\
    & - \int_{\mathbb{U}} dU U^{\otimes 2}(\cdot)(U^{\dagger})^{\otimes 2},
\end{align}
with $d_{\mu}(V)$ the volume element of the Haar measure, and $dU$ the uniform distribution over $\mathbb{U}$, $V \in \mathcal{U}_N$ and $U \in \mathbb{U}$. If $\mathcal{A}_\mathbb{U}(\hat{O}) \rightarrow 0$, then the ansatz producing $\mathbb{U}$ approaches a 2-design and therefore offers maximal expressibility. From this super-operator, one can compute a metric for expressibility of an ansatz as
\begin{align}
    &\varepsilon_{\mathbb{U}}^{\rho} := || \mathcal{A}_\mathbb{U}(\rho^{\otimes 2})||_2 \label{eq:expressibility_density} \\
    &\varepsilon_{\mathbb{U}}^{\hat{P}} := || \mathcal{A}_\mathbb{U}(\hat{P}^{\otimes 2})||_2. \label{eq:expressibility_operator} 
\end{align}
Consequently, the expressibility of an ansatz can be expressed with respect to an initial input state ($\rho$), or with respect to a measurement operator ($\hat{P}$). Following the equations above, one can interpret that if $\varepsilon = 0$ the ansatz is maximally expressive, while expressibility decreases as $\varepsilon$ increases.  
Expressibility has also been shown to be a convenient metric for assessment of parametrized quantum circuits more generally \cite{Nakaji2021}. In addition, several methods have been proposed to remove redundant parameters from quantum circuits without decreasing expressibility \cite{Rasmussen2020} or reducing the set of states that can be generated through the circuit \cite{Funcke2021}.

\paragraph{Trainability:} The trainability of an ansatz refers to the ability to find the best set of parameters of the ansatz by (iteratively) optimizing the ansatz with respect to expectation values of the Hamiltonian in a tractable time \cite{Cerezo2021_BP, Holmes2021}.
More specifically, an ansatz is considered trainable if its expected gradient vanishes at most polynomially as a function of the various metrics of the problem (e.g. system size, circuit depth). On the other hand, if the gradient vanishes exponentially, it is said to suffer from the barren plateau problem. 
In this section, we first provide a review of the barren plateau problem \cite{McClean2018}, which is the main known obstacle to ansatz trainability, and discuss its implication for the VQE in Sec. \ref{sec:barren_plateau}. We then describe of the most relevant fixed-structure ansatz for the VQE in Sec. \ref{sec:fixed_struct}, followed by a description of the most relevant adaptive structure ansatz in Sec. \ref{sec:adaptive_ansatz}. Finally, we provide a discussion regarding ansatz selection for the VQE in Sec. \ref{sec:ansatz_discussion}. For alternative recent reviews of ansatz selection for the VQE, we recommend Refs.~\cite{Fedorov2021, Anand2021_review}.

\subsection{The barren plateau problem} \label{sec:barren_plateau}

A key issue that is inherent to all types of variational quantum algorithms is the risk of vanishing gradients, either during training or as a result of a random initialization \cite{McClean2018}. This refers to the risk of the cost function gradients vanishing exponentially as a function of specific properties of the optimization for a problem. McClean \textit {et al.} \cite{McClean2018} provide the first formal characterization of this barren plateau problem (some early numerical evidence of this problem are outlined in Ref.~\cite{Wecker2015}, without a characterization being provided), and show that cost function gradients are vanishing exponentially in the number of qubits in the quantum register when provided with random initialization of the circuit parameters. Even though this problem is akin to the vanishing gradient problem in machine learning, it has two striking differences that make it significantly more impactful on the prospects of variational quantum algorithms \cite{McClean2018}:
\begin{itemize}
    \item The estimation of the gradients on a quantum device is essentially stochastic. Any observable can only be measured to a certain precision, increasing as the inverse square root of the number of shots (see Sec. \ref{eq:measurement_scaling}). If gradients are exponentially approaching zero, it means that distinguishing between a positive and a negative gradient becomes increasingly difficult. Failing to establish the sign of the gradient reliably transforms the optimization into a random walk, overall requiring an exponential number of shots to continue optimization.
    \item The barren plateau problem is dependent on the number of qubits (while the problem is dependent on the number of layers for the vanishing gradient problem). Additional research also shows that it can be linked to other factors specific to quantum circuits, including expressibility of the ansatz \cite{Holmes2021}, degree of entanglement of the wavefunction \cite{OrtizMarrero2020, Patti2021}, non-locality of the wavefunction \cite{Cerezo2021_BP, Uvarov2020, Sharma2020}, or quantum noise \cite{Wang2020}.
\end{itemize}

Before describing key drivers of the barren plateau problem in more detail, and potential methods to address it, it is worth briefly discussing the typical cost function landscape for single parameters in the variational quantum eigensolver. Another problem that affects this landscape is that of 'narrow gorges' (initially characterized in \cite{Cerezo2021_BP}). It refers to the fact that the local minimum (well defined by the region starting from the end of a barren plateau and going towards a local minimum) contracts exponentially in the number of qubits. Interestingly, it was shown that these two problems are equivalent \cite{Arrasmith2021}. An alternative way to present the barren plateau problem is that it implies the expectation value of an observable with respect to a random state concentrates exponentially around the mean value of that observable \cite{McClean2018}, rendering intractable optimization away from the mean. 

In the context of the VQE, the barren plateau problem can be formally characterized as follows. Consider a VQE optimization problem with cost function:
\begin{equation} \label{eq:vqe_cost}
E(\boldsymbol{\theta}) = \bra{\psi(\boldsymbol{\theta)}} \hat{H} \ket{\psi(\boldsymbol{\theta})},
\end{equation}
with $\hat{H}$ the molecular Hamiltonian operator, and $\ket{\psi(\boldsymbol{\theta})}$ the parametrized wave function with a vector $\boldsymbol{\theta}$ of parameters.
This cost function exhibits a barren plateau if, for any $\theta_i \in \boldsymbol{\theta}$ and for any $\epsilon > 0 $ there is $b > 1$ such that:
\begin{equation}
    Pr( |\partial_{\theta_i} E(\boldsymbol{\theta})| \geqslant \epsilon ) \quad \leqslant \quad \mathcal{O}(\frac{1}{b^N}),
\end{equation}
which is an immediate consequence of Chebyshev's inequality and the result from above (for the expectation value and variance) \cite{Cerezo2021_BP}. This means that the probability of a gradient being above a certain threshold (which could be arbitrarily small), can always be upper-bound by a number that decreases exponentially in the system size $N$. It is however important to note that while defined with respect to a cost gradient, the barren plateau problem also affects gradient-free optimizers \cite{Arrasmith2020_BP_GF, OrtizMarrero2020} (e.g. COBYLA, Powel, Nelder-Mead, RotoSolver, see Sec. \ref{sec:Optimization}). It is easy to understand, as gradient-free optimizers usually rely on sampling the cost landscape of specific parameters. If the variance across the landscape is too small, then it becomes impossible to accurately progress through the optimization step.

\subsubsection{Drivers of the barren plateau problem}

\paragraph{System size and random initialization \cite{McClean2018}:} The barren plateau problem refers to the fact that the gradient of a cost function incorporating a layered ansatz has an exponentially vanishing variance, and values approaching zero in the number of qubits, provided ansatz parameters are initialized randomly. A layered ansatz for a random parametrized quantum circuit can be described as \cite{McClean2018}
\begin{equation} \label{eq:layered_ansatz}
    U(\boldsymbol{\theta}) = \prod_{l = 1}^L U_l(\theta_l) \mathcal{W}_l,
\end{equation}
where $U(\theta)_l = e^{-i\theta_l \hat{V}_l}$, with $\hat{V}_l$ a hermitian operator, and $\mathcal{W}_l$ a generic non-parametrized unitary. The cost function is as described in Eq.~(\ref{eq:vqe_cost}), taking $\ket{\psi(\boldsymbol{\theta})} = U(\boldsymbol{\theta}) \ket{0}$. The gradient of this cost function with respect to any given parameter $\theta_i$ can be conveniently computed as
\begin{equation} \label{eq:layered_ansatz_gradient}
    \partial_{\theta_i} E = i \bra{0} U^{\dagger}_{1 \rightarrow (i - 1)} \left[\hat{V}_i, U^{\dagger}_{i \rightarrow L} \hat{H} U_{i \rightarrow L}  \right] U_{1 \rightarrow (i - 1)} \ket{0}.
\end{equation}
where $1 \rightarrow (i - 1)$ represent the ansatz layers from layer index $1$ to layer index $(i - 1)$, and $i \rightarrow L$ represent the ansatz layers from layer index $i$ to layer index $L$. From the computation of the gradient, McClean et al. \cite{McClean2018} show that if both $U_{1 \rightarrow (i - 1)}$ and $U_{i \rightarrow L}$ are 2-designs, the variance of the gradient is clearly vanishing exponentially in the system size:
\begin{equation}
    \mathrm{Var}[\partial_{\theta_i} E] \approx \frac{1}{2^{(3N - 1)}} Tr\left[\hat{H}^2\right] Tr\left[\rho^2\right] Tr\left[\hat{V}^2\right] 
\end{equation}
Cases in which either of $U_{1 \rightarrow (i - 1)}$ or $U_{i \rightarrow L}$ is not a 2-design are also addressed in Ref.~\cite{McClean2018}, with similar outcomes (we direct readers to this reference for a full demonstration, as well as detailing of the rules needed to compute the expected value of a variance over an ansatz). Further analysis conducted by Napp in Ref. \cite{Napp2022} shows additional analytical bounds for unstructured variational ans{\"{a}}tze, moving away from the layered ansatz described above. 

\paragraph{Expressibility \cite{Holmes2021}:} Holmes et al. show that trainability and expressibility of the ansatz are inversely related. In other words, the more expressive an ansatz is, the more prone it is to barren plateaus. This does not mean that low-expressivity ans\"atze are not affected by barren plateaus, as other drivers can otherwise trigger the problem (for instance, system size and random initialization, as above, or a very non-local cost function \cite{Cerezo2021_BP, Uvarov2020, Sharma2020}). This observation implies that one cannot lower-bound gradients as a function of expressibility, but it can be upper-bounded.

This is shown in Ref.~\cite{Holmes2021} by extending the expression of the barren plateau problem as explained in Ref. \cite{McClean2018}, and setting an upper bound for the variance of the cost gradient as a function of the ansatz' distance to a 2-design. As such, they use the same layered ansatz template (Eq. \ref{eq:layered_ansatz}) and resulting gradients (Eq. \ref{eq:layered_ansatz_gradient}). As an illustration, Ref.~\cite{Holmes2021} find a generalized bound for gradient variance as a function of expressibility (we encourage the reader to read the finer details directly from the source material), as
\begin{equation}
    \mathrm{Var}[\partial_{\theta_i}, E] \leqslant \frac{g (\rho, \hat{P}, U)}{2^{2N}- 1} + f(\varepsilon^{\hat{P}}_L, \varepsilon^{\rho}_R),
\end{equation}
where the first half of the bound corresponds to the maximally expressive ansatz (and $g(.)$ is a function defining a pre-factor on this expressibility, defined in detail in Appendix E of Ref.~\cite{Holmes2021}). The function $f(.)$ is the extra bound resulting from the expressibility (or lack thereof) of the ansatz, defined as
\begin{equation}
    f(\varepsilon_x, \varepsilon_y) := 4\varepsilon_x \varepsilon_y + \frac{2^{N + 2} ( \varepsilon_x ||\hat{P}||^2_2 + \varepsilon_y||\rho||^2_2) }{2^{2N} - 1},
\end{equation}
and in which $\varepsilon^{\hat{P}}_L$ (the expressibility metric for the part of the ansatz to the left of the parameter $i$, where the gradient is taken with respect to the measurement operator), and  $\varepsilon^{\rho}_R$ (the expressibility metric for the part of the ansatz to the right of the parameter $i$, where the gradient is taken with respect to the state density matrix), have been used as arguments. From this equation, one can see that the gradient variance admits an upper-bound approaching $\mathcal{O}(\varepsilon^{\hat{P}}_L \varepsilon^{\rho}_R)$ as $N \rightarrow \infty$. As a result of the definitions in Eqns.~(\ref{eq:expressibility_integral}-\ref{eq:expressibility_operator}), it shows that high expressibility (low $\varepsilon$) lowers the gradient variance bound and therefore limits the trainability of the ansatz. For further information on expressibility of ans\"atze, Nakaji et al. \cite{Nakaji2021} provide a study of the expressibility of the shallow alternating layer ansatz. 

\paragraph{Cost function non-locality: \cite{Cerezo2021_BP, Uvarov2020, Sharma2020}:} In Ref.~\cite{Cerezo2021_BP}, Cerezo et al. show that an ansatz trained on local cost functions are more resilient to the barren plateau problem than those trained on global cost functions. They illustrate this point by comparing a cost function constructed around the expectation value of a global observable: $\hat{O}_G = \unit - \ket{0}\bra{0}^{\otimes N}$ to a cost function constructed around the expectation value of a local observable $\hat{O}_L = \unit - \frac{1}{N} \sum_i^N \ket{0}\bra{0}_i \otimes \unit_{\neq i}$, the latter being local as each component of the observable only applies to a single qubit. It is shown in particular that while alternative layered ans{\"{a}}tze trained on the global cost function are never trainable (this is not necessarily true on other types of  ans{\"{a}}tze), ans{\"{a}}tze trained on the local cost function are trainable if their depth scales logarithmically with the circuit width (i.e. $\mathcal{O}(\log(N))$ or below). Cerezo et al. \cite{Cerezo2021_BP} also show that ans{\"{a}}tze with a scaling  $\mathcal{O}(\mathrm{poly}(\log(N)))$ could also be either trainable or not. Ref. \cite{Uvarov2020} extend these findings to a wider range of cost functions, and Ref.~\cite{Sharma2020} demonstrated the occurrence of this phenomenon in the case of Dissipative Perceptron-Based Quantum Neural Networks. 

An important consequence for the VQE, as pointed out in \cite{Cerezo2021_BP} is that local encoding such as Bravyi-Kitaev \cite{Bravyi2002, Seeley2012, Tranter2015} (Sec. \ref{sec:bravyi-kitaev}), ternary tree encoding \cite{Jiang2020} (Sec. \ref{sec:ternary_tree_encoding}) or Generalized Superfast Encoding \cite{Setia2019} (Sec. \ref{sec:superfast_encoding}) with lower Pauli weight, would offer more resilience than encodings such as Jordan-Wigner \cite{Jordan1928} (Sec. \ref{sec:jordanwigner}) which has Pauli weights scaling of $\mathcal{O}(N))$, therefore resulting in a very non-local VQE cost function. It is also worth noting that the best known scaling for a VQE ansatz is linear (e.g. k-UpCCGSD \cite{Lee2019}, Sec. \ref{sec:UCCA}, Fourier Transform-HVA \cite{Babbush2018} on some systems, Sec. \ref{sec:hva}). Uvarov \textit{et al.} \cite{Uvarov2020_frustrated} compares numerically the impact of using Jordan-Wigner compared to Bravyi-Kitaev on a Hubbard-like model and find that in this case the latter results in gradient variance nearly one order of magnitude larger than the former. This should be caveated by the fact that the numerical results in Ref.~\cite{Uvarov2020_frustrated} also show that the number of layers used in the ansatz (in this case, a symmetry preserving ansatz is used, similar to the one presented in Ref.~ \cite{Barkoutsos2018}) ultimately dominates and reduces gradient variance to a negligible number in either case.

\paragraph{Noise induced barren plateau (NIBP):} Wang \textit{et al.} \cite{Wang2020} show that incorporating quantum noise in a variational optimization can accelerate the occurrence of barren plateaus, and additionally result in vanishing of the amplitude of the expectation value. Their main result is a bound on the value of a parameters' gradient (with notation slightly changed from Ref.~\cite{Wang2020}), as
\begin{equation}
    \left| \frac{\partial \langle \hat{H}(\boldsymbol{\theta}) \rangle}{\partial \theta_i}  \right| \leq G(N)q^{L+1},
\end{equation}
where $q < 1$ is a parameter representing the strength of the noise model (the lower it is, the more noise there is), $G(N) \sim \mathcal{O}(2^{-\alpha N})$ with $\alpha$ an arbitrary, positive constant, and $L$ represents the number of layers in the ansatz. A few important points can be raised as a consequence of this bound \cite{Wang2020}. First, the noise-induced barren plateau is independent of parameter initialization, or locality of the cost function, meaning that some of the strategies listed in Sec. \ref{sec:bp_mitigation} will not work in a noisy setting. Second, this bound is conceptually different from the previously described drivers of barren plateaus as it is a bound on the gradient, rather than on the variance of the gradient. Rather than the flattening optimization landscape described previously, NIBP results in the vanishing of the amplitude of the expectation value function and a bias away from the minimum. 

\paragraph{Large degrees of entanglement \cite{OrtizMarrero2020, Patti2021}:} The degree of entanglement of the trial wavefunction has also been shown to be associated with the barren plateau problem. In particular, Patti \textit{et al.} show that one can link vanishing gradients to the entanglement entropy \cite{nielsenQuantumComputationQuantum2010} of the trial state wavefunction even at low circuit depth. Ortiz Marrero \textit{et al.} reach a similar conclusion by first showing that entanglement between visible and hidden units in a Quantum Neural Network reduces trainability. The result is then extended to unitary networks (very much similar to UCC based ans\"atze) and quantum Boltzmann machines. 
A final point to note is that it was also shown that higher-order derivatives of the cost function are also affected by the barren plateau problem, and therefore cannot be used as a means to circumvent it \cite{Cerezo2021_BP_higher_order}.

\subsubsection{Methods to address barren plateau problem} \label{sec:bp_mitigation}

It follows from Refs.~\cite{McClean2018} and \cite{Holmes2021} that addressing the barren plateau problem can be done through modification of the ansatz. In particular, techniques focusing on selectively reducing the expressibility of the ansatz, or in other words, avoiding a 2-design (which would be the maximally expressive unitary on a given Hilbert space) are expected to be more resilient to barren plateaus. In the context of the VQE, this can be done by restricting the span of the ansatz to a section of the Hilbert space of interest. In particular, it was shown that adaptive ans{\"{a}}tze (Sec. \ref{sec:adaptive_ansatz}) exhibit some resilience to the barren plateau problems. In addition, there are optimization methods which aim at tempering this problem (for example Ref.~\cite{haug_optimal_2021}) that are considered further in Sec.~\ref{sec:Optimization}. Another means available to contain the barren plateau problem is to select a local encoding (see Sec. \ref{sec:Encoding}) with low Pauli weights, as discussed above and explained in Ref.~\cite{Cerezo2021_BP}.

Some methods have also been developed specifically to address barren plateaus. A first example consists of initializing ansatz parameters such that subsections of the ansatz (as split when computing the gradient) do not form a 2-design, at the very least avoiding to start the optimization process in a barren plateau \cite{Grant2019}. Starting from the layered ansatz in Eq.~(\ref{eq:layered_ansatz}), we can divide the ansatz into $K$ blocks of depth $D$ (such that the total depth $L = KD$). The depth $D$ of each block considered in isolation needs to be shallow enough to ensure that the block does not approach a 2-design. Each block $U_k(\boldsymbol{\theta}_k)$, parametrized by a vector $\boldsymbol{\theta}_k$ can then be split into two parts of equal depth, such that
\begin{equation}
    U_k(\boldsymbol{\theta_k}) = \prod_{d=1}^{D/2 - 1} U_d(\theta^k_{d, 1}) W_d \prod_{d=D/2}^{D} U_d(\theta^k_{d, 2}) W_d,
\end{equation}
where $\theta^k_{d, 1}$ can be initialized at random, but where $\theta^k_{d, 2}$ are initialized such that $U_d(\theta^k_{d, 2}) W_d  = (U_d(\theta^k_{d, 1}) W_d)^{\dagger}$. The result is that, for all $k$, before any optimization, we have
\begin{equation}
    U_k(\boldsymbol{\theta}_k) = I_k, \quad  \mathrm{and} \quad U(\boldsymbol{\theta}_{init}) = I.
\end{equation}

Grant et al. \cite{Grant2019} show that this parameter initialization strategy could slow down the optimization process of the VQE as the initial state produced by the circuit would have no entanglement. They propose to initialize the qubit register with a random entangled state, using a shallow random unitary which remains constant throughout the optimization process. While showcasing promising results on small systems, the method is however quite challenging to implement in practice. Identifying a block initialization is not directly possible for all ansatz structures: for example it is not straightforward for unitary coupled cluster (see Sec. \ref{sec:UCCA}) based ansatz without repeating some operators, and it is in general not possible exactly with hardware efficient ans{\"{a}}tze. 

Nonetheless, the idea of adjusting parameter initialization to improve resilience to the barren plateau problem has been extended to alternative mitigation techniques. In Ref.~\cite{Sauvage2021}, Sauvage \textit{et al.} propose to select optimal initial parameters with the help of a machine learning model (FLexible Initializer for arbitrarily-sized Parametrized quantum circuits, or FLIP). The model is trained to identify structures of parameters that best suit specific families of quantum circuit optimization problems, and is numerically shown to provide significant improvements. Similarly, Kulshrestha and Safro show that initializing ansatz parameters by picking them from a beta distribution reduces the impact of the barren plateau problem compared to picking them from a uniform distribution \cite{Kulshrestha2022}. They also show that adding perturbations to the parameters between each optimization step also helps in mitigating vanishing gradients.

Several additional methods have been developed for the barren plateau in the general case of parametrized quantum circuits. In Ref.~\cite{Volkoff2021}, Volkoff et al. show that one can reduce the dimensionality of the parameter space by using spatially and temporally correlated parameterized quantum gates, resulting in higher resilience to barren plateaus. The ansatz can also be trained layer by layer to the same effect \cite{Skolik2021}, though limitations of this method were shown in Ref.~\cite{Campos2021}. This is somewhat akin to adaptive ans{\"{a}}tze (see Sec. \ref{sec:adaptive_ansatz}), but generalized to any quantum neural network optimization. Patti \textit{et al.} \cite{Patti2021} also propose several additional mitigating methods including an alternative initialization strategy in which two qubit registers are initially not entangled, regularization on the entanglement, the addition of Langevin noise, or rotation into preferential cost function eigenbases. Sack \textit{et al.} \cite{Sack2022} showed that barren plateaus can be partially mitigated as part of a classical shadow measurement scheme. Wu \textit{et al.} \cite{Wu2021_mit} propose to mitigate the impact of NIBP by defining an alternative cost function with the same optimal state but without sensitivity to vanishing gradients, by identifying and eliminating the dominant term in the Pauli representation of the observable measured.
Finally, though not directly relevant to VQE, Pesah et al. \cite{Pesah2020} show numerically that Quantum Convolutional Neural Networks exhibit natural resilience to the barren plateau problem. Similarly, Zhang \textit{et al.} \cite{Zhang2020} show that Quantum Neural Networks with tree tensor structure and step-controlled architectures have gradients that vanish at most polynomially in the system size. 

\subsubsection{Comments on barren plateau in the context of the VQE} \label{sec:bp_for_vqe}

In Ref.~\cite{Holmes2021}, Holmes et al. point out that the problem structure of VQE can be used to limit the impact of barren plateaus. The features in question include symmetries of the problem, which can be used to reduce the portion of the Hilbert space, or physically-motivated ans\"atze targeting a restricted part of the Hilbert space in which good approximations of the ground state are expected to be. Such relevant structures are in general more difficult to find when considering the wider field of quantum neural networks. 
Adopting an initialization strategy such as the ones presented in Refs.~\cite{Grant2019, Sauvage2021, Patti2021} would allow an ansatz to begin optimization away from a barren plateau, and as such, away the target operator mean. One could argue that given the optimization problem aims at finding a minimum, a reliable optimizer should always move a state away from the mean expectation value and therefore away from the barren plateaus regions. This point however could be invalidated by several aspects of the optimization process. These include the existence of local minima, the increase in entanglement of the trial wavefunction as the optimization progresses, or the presence of noise which results in vanishing of the value function amplitude. 

Focusing on local encodings (see Sec.\ref{sec:Encoding}) has been shown to provide some resilience to barren plateaus \cite{Cerezo2021_BP, Uvarov2020, Uvarov2020_frustrated}, suggesting that using VQE on lattice models with limited dimensions could be performed relatively better than on a molecular Hamiltonian in that respect. As pointed out in Ref.~\cite{Cerezo2021_BP}, ans\"tze scaling logarithmically in the system size, and measured on local observable are resilient to barren plateaus. At this stage, however, there is no known VQE ansatz scaling as such that also guarantees an accurate description of the ground state. 

In the remainder of this section, we discuss options for ans{\"{a}}tze in the context of VQE. We look at two different types of ansatz: fixed structure ansatz (Sec. \ref{sec:fixed_struct}) which are set at the beginning of the optimization process and remain unchanged afterward, and adaptive structure ansatz (Sec. \ref{sec:adaptive_ansatz}) which are constructed iteratively as part of the optimization process. We can present three key metrics to compare ans\"tze: 
\begin{itemize}
    \item The depth of the ansatz (number of sequential operations required for the implementation), which impacts the overall runtime of the method, its resilience to noise and to barren plateaus.
    \item The number of parameters, which significantly influence the overall runtime of the implementation (although this cost can in theory, and in most cases, be entirely parallelized, see Sec. \ref{sec:parallelization}), and the complexity of the optimization process.
    \item The number of entangling gates, which is, in general, the main source of noise resulting from execution of a quantum circuit.
\end{itemize}
Of course, while these metrics can be objectively defined and provide a useful tool to compare different ans\"atze, they are only relevant if the ans\"atze studied can indeed provide an accurate description of the ground state wavefunction. This latter point is far more difficult to assess, beyond the formal considerations at the beginning of this chapter.

\subsection{Fixed structure ans{\"{a}}tze} \label{sec:fixed_struct}

Fixed structure ans{\"{a}}tze are initialized at the beginning of the VQE process and remain unchanged (aside from the value of their parameters) throughout the optimization. Table  \ref{tab:ansatz_scaling} provides a comparative summary of these ans{\"{a}}tze. Some fixed structure ans{\"{a}}tze (such as the Qubit Coupled Cluster \cite{Ryabinkin2018}, and Qubit Coupled Cluster Singles and Doubles \cite{Xia2020}) are only discussed in the adaptive ans{\"{a}}tze section as their adaptive version tend to be more relevant for discussion.

\begin{table} [ht]
\caption{Summary of circuit depth, parameters and entangling gates scaling across most fixed structure ans{\"{a}}tze reviewed. The scaling in the number of entangling gates assumes full connectivity of the qubit lattice.}
\label{tab:ansatz_scaling}
\begin{tabularx}{\linewidth}{p{0.15\linewidth}|p{0.14\linewidth}p{0.14\linewidth}p{0.14\linewidth}X}
\toprule
\\  Method & Depth & Parameters & Entangling gates & Comments \\
\midrule
    Hardware Efficient Ansatz (HEA) \cite{Kandala2017} & $\mathcal{O}\left(L \right)$ & $\mathcal{O}\left(NL \right)$ & $\mathcal{O}\left((N - 1)L \right)$ & $L$ is an arbitrary number of layers, its scaling for exact ground state is unknown, exponential in the worst case (i.e. if the entire Hilbert space needs to be spanned to find the ground state) \\
\hline
    UCCSD \cite{Peruzzo2014, Romero2019}& $\mathcal{O}\left((N - m)^2m\tau \right)$ &$\mathcal{O}\left((N-m)^2m^2 \tau \right)$& $\mathcal{O}\left(2(\tilde{q} -1)N^4 \tau\right)$ & $\tilde{q}$ is the average Pauli weight across the operators used to build the ansatz. As an indication, maximum Pauli weight under Jordan-Wigner is $N$, and $log(N)$ under Bravyi-Kitaev. $\tau$ is the number of Trotter steps used\\
\hline
    UCCGSD \cite{Peruzzo2014, Wecker2015, Lee2019}& $\mathcal{O}\left(N^3 \tau \right)$ & $\mathcal{O}\left(N^4 \tau \right)$& $\mathcal{O}\left(2(\tilde{q} -1)N^4 \tau\right)$ & As above\\
\hline
    k-UpCCGSD \cite{Lee2019}&$\mathcal{O}\left(kN \tau \right)$& $\mathcal{O}\left(k\tau N^2/4 \right)$& $\mathcal{O}\left(k\tau(\tilde{q} -1) N^2/2 \right)$& $k$ is an arbitrary constant which determines the accuracy of the result. Scaling is unknown. Rest is as above. \\
\hline
    OO-UCCD \cite{Mizukami2020} & $\mathcal{O}\left((N - m)^2m\tau \right)$ &$\mathcal{O}\left((N-m)^2m^2 \tau \right)$& $\mathcal{O}\left(2(\tilde{q} -1)N^4 \tau\right)$ & Same as UCCSD. It is worth noting that OO-UCCD is a nested loop between orbital (one-body terms) optimization, done on a conventional machine, and two-body terms optimization done on the quantum computer.
\\
\hline
    Symmetry Preserving \cite{Barkoutsos2018} & $\mathcal{O}\left( (N-1)L \right)$&$\mathcal{O}\left(2(N-1)L \right)$&$\mathcal{O}\left(3(N-1)L \right)$& This ansatz spans a wider range of the Hilbert space than the EPS. It is therefore likely it requires more circuit resources and as such we suspect that $L$ grows exponentially in $N$ for exact resolution of the ground state. This logic also applies to HEA. \\
\hline
     Efficient Symmetry Preserving (EPS) ansatz \cite{Gard2020} & $\mathcal{O}\left(2\binom{N-1}{m} \right)$ & $\mathcal{O}\left(2\binom{N}{m} - 2 \right)$ & $\mathcal{O}\left(3\binom{N}{m} \right)$& Scaling range from linear when $m=1$, or $m=N-1$, to exponential if $m\sim N/2$\\
\hline
    Hamiltonian Variational Ansatz \cite{Wecker2015, Wiersema2020} & $\mathcal{O}\left(\tilde{C} L \right)$ & $\mathcal{O}\left(\tilde{C} L \right)$& $\mathcal{O}\left(2(\tilde{q} -1)C L\right)$ & $L$ represents the number of repetition of the ansatz required to achieve the desired accuracy. $C$ is the number of terms in the Hamiltonian, and $\tilde{C}$ the number of commutative groups among these terms.
\\
\bottomrule
\end{tabularx}
\end{table}

\subsubsection{Hardware-efficient ansatz (HEA)} \label{sec:HEA}

The initial motivation for the Hardware-Efficient ansatz (HEA) was for the trial state of VQE to be parametrized by quantum gates directly tailored to the quantum device on which the experiment is run \cite{Kandala2017}. Several flavors of the HEA have been proposed, however, they all follow the same logic: the ansatz is constructed by repeating blocks of interweaved single qubit, parametrized, rotation gates, and ladders of entangling gates (see Fig.~\ref{fig:HEA} for an example). A generic representation of the HEA can be presented as follows:

\begin{equation} \label{eq:HEA_unitaries}
\ket{\psi (\theta)} = \left[ \prod_{i=1}^d U_{rota}(\theta_i) \times U_{ent} \right] \times U_{rota}(\theta_{d + 1}) \ket{\psi_{init}},
\end{equation}
where $U_{rota}(\theta_i) = \prod_{q, p}^{N, P} R_p^q(\theta_i^{pq})$, with $q$ the qubit addresses and $p \in \{X, Y, Z\}$, the selected set of parametrized Pauli rotations.


\begin{figure}[ht]
\centerline{
\Qcircuit @C=1em @!R {
   \lstick{\ket{q_1}}   &   \qw   &   \gate{R_x(\theta_i)}   &    \gate{R_y(\theta_j)}    &  \ctrl{1} &  \qw  & \qw                    \\
   \lstick{\ket{q_2}}   &   \qw   &   \gate{R_x(\theta_p)}   &    \gate{R_y(\theta_q)}    &  \targ & \ctrl{1} & \qw                     \\
   \lstick{\ket{q_3}}   &   \qw   &   \gate{R_x(\theta_m)}   &    \gate{R_y(\theta_n)}    &  \qw & \targ & \qw                     \\
}
} \caption{Example of one block of a HEA, using $R_x$ and $R_y$ as rotation gates and $CNOT$ as entangling gates, on three qubits} \label{fig:HEA}
\end{figure}

Both the set of rotation gates and entangling gates can vary depending on the native gate set of the device, and the complexity of the target state sought \cite{Mitarai2019}. The ansatz' entangling section was originally presented as a quantum analogue task \cite{Kandala2017}. The main promise of HEA is that it can be flexibly tailored to the specific native gate set of the device used, while at the same time being highly expressive. Its versatility and ease of construction resulted in it being widely used for numerous small-scale quantum experiments~\cite{Kandala2017, Mitarai2019, higgottVariationalQuantumComputation2019, Tilly2020, Tilly2021, Chen2021}.

There are however many known limitations of HEA. A first obvious issue is the fact that it must span a very large portion of the Hilbert space to guarantee that an accurate enough representation of the ground state wavefunction can be produced. HEA can therefore be quite inefficient with respect to its required Hilbert space coverage, requiring in worst cases an exponential depth (though further research would be required to verify how the accuracy of ground state representations would respond to arbitrary depth reduction and shrinkage of the Hilbert space coverage). An immediate consequence is that HEA is significantly limited by barren plateaus \cite{Holmes2021} (see Sec. \ref{sec:barren_plateau}, \cite{McClean2018}). It also implies that a large number of parameters need to be optimized and managed (for a numerical example of the number of parameters that HEA requires compared to other ans{\"{a}}tze, one can refer to Table II in Ref.~\cite{Choquette2021}, where $198$ parameters are required for a $12$ qubit version of $\mathrm{H_2O}$, against $8$ for UCCSD detailed below). Regarding this last point, Wu \textit{et al.} have shown that certain architectures of HEA provide higher expressibility and can be overall more efficient in terms of quantum resources \cite{Wu2021_hea}.
With some caveats, Bravo-Prieto \textit{et al.} \cite{BravoPrieto2020} demonstrate that HEA type structures can provide reasonable accuracies on spin chain models such as Ising or XXZ chains using a number of layers at least linear in the system size. 
Overall, the HEA is a convenient tool for a proof of principle for a given algorithm or optimization strategy. It is, however, unlikely to be suitable for general larger-scale chemical problems. One therefore would rather turn toward more problem-tailored ans{\"{a}}tze.

\subsubsection{The Unitary Coupled Cluster (UCC) Ansatz and extensions}  \label{sec:UCCA}

The Unitary Coupled Cluster (UCC) ansatz is arguably the most studied ansatz for VQE. It featured in the initial VQE work of Peruzzo et al. \cite{Peruzzo2014} and has occupied an important position in the literature since then. As such, we have split this section into three parts: a presentation of the general UCC framework, a description of the extensions that have been proposed, and a discussion on the benefits and issues of the ansatz. An extensive review dedicated to this family of ans{\"{a}}tze was recently published by \cite{Anand2021_review}, we direct reader in search for further information towards it.\\

It is worth noting that while initially designed in the context of electronic structure computation, variants of UCC have also been applied in other contexts. For example, it is been applied to variational quantum computation of ground and excited states for periodic systems \cite{Yoshioka2022, Manrique2020, Liu2020}, and for vibrational spectroscopy (with the Unitary Vibrational Coupled Cluster ansatz proposed in Ref. \cite{McArdle2019_vibra}, and applied in Ref. \cite{Ollitrault2020_vibrational}). 


\textbf{General framework} \\

The UCC theory \cite{Bartlett1989, Taube2006, Filip2020} stems from adapting the Coupled Cluster (CC) theory. CC is a post Hartree-Fock method that aims at recovering a portion of electron correlation energy by evolving an initial wave function (usually the Hartree-Fock wave function) under the action of parametrized excitation operators \cite{Coester1960, Cizek1966, Paldus1972, Paldus1977, Cizek1980, Bartlett2007}.

In general, these are single-electron excitations and double electron excitations, resulting in CC Single and Double (CCSD),  however, these can be extended systematically to higher-order (e.g. CCSDT). Only excitation operators allowing transitions from an occupied orbital to an unoccupied orbital are traditionally included in CC (note that we use $i$, $j$, $k$, and $l$ for occupied orbital indices, $a$, $b$, $c$, and $d$ for virtual orbital indices and $p$, $q$, $r$, and $s$ for either).
The action of these operators on the initial state is performed through exponentiation of part of the cluster operator $T$. For $\nu$ denoting the maximum allowed excitation, we have:
\begin{equation}
    \hat{T} = \hat{T}_1 + \hat{T}_2 + ... \hat{T}_{\nu},
\end{equation}
with for example the single and double excitation operators:
\begin{align}
\hat{T}_1 &= \sum_{ia} t_{i}^a\hat{a}^{\dagger}_a \hat{a}_i \label{eq:T_one_body} \\
\hat{T}_2 &= \sum_{ijab} t_{ij}^{ab}\hat{a}^{\dagger}_a \hat{a}^{\dagger}_b \hat{a}_j \hat{a}_i. \label{eq:T_two_body}
\end{align}
Using the Hartree-Fock state as reference state, the CC ansatz wave function is given by
\begin{equation}
\ket{\psi} = e^{\hat{T}} \ket{\psi_{HF}}.
\end{equation}

The conventional resolution method for CCSD scales $\mathcal{O}(m^2(N - m)^4)$, with $m$ the number of electrons, and $N$ the number of spin orbitals. CCSD is however in general not variational and has been reported to fail in numerous cases, in particular in systems with strong correlation, with possible solutions to avoid these failures usually scaling exponentially in the system size (for further reading on CC theory, failures and how they can be addressed, we direct the reader toward Refs.~\cite{Paldus1984, Piecuch1995, Small2012, Small2014, Lee2017, Lee2018}). Another issue in the context of the VQE is that the operator $e^{\hat{T}}$ is not unitary, and therefore the CC ansatz cannot be implemented as a series of quantum gates.

The UCC method was developed as a way to address these limitations \cite{Bartlett1989, Taube2006, Filip2020}. It is based on the fact that for any linear operator $\hat{T}$, the expression $(\hat{T} -\hat{T}^{\dagger})$ is an anti-Hermitian operator. The exponential of an anti-Hermitian operator is a unitary operator, and the difference between the cluster operator and its complex conjugate can be used as an evolution operator to form a unitary version of CC. Elements of the truncated cluster operator for UCC are identical to that of CC, as presented in Eq.~(\ref{eq:T_one_body}) and Eq.~(\ref{eq:T_two_body}).
\begin{equation}
    \ket{\psi} = e^{\hat{T} - \hat{T}^\dagger} \ket{\psi_{HF}}.
\end{equation}
The energy can then be evaluated using a variational approach based on the Ritz functional (see Sec.~\ref{sec:overview}). Exact evaluation of this functional for UCC on classical resources is known to scale exponentially in the system size \cite{Taube2006}. It is therefore natural to bring this ansatz to quantum computation.

By grouping the individual excitation operators in $\hat{T}$ with their corresponding conjugate in $\hat{T}^{\dagger}$, and denoting them as $\tau$, we can obtain the parametrized version of the UCC ansatz:
\begin{equation} \label{eq:ucca}
U(\vec{t}) = e^{\sum_j t_j(\tau_j - \tau^\dagger _j)},
\end{equation}
where $t_j$ correspond to the amplitude weights presented in Eq.~(\ref{eq:T_one_body}) and Eq.~(\ref{eq:T_two_body}), and with $j$ spanning all the excitation operators included. Akin to our description of CC, UCC can accept several level of excitations (UCCSD, UCCSDT).

Using any of the mappings described in Sec. \ref{sec:Encoding} we can re-write each of the fermionic operators as

\begin{equation} \label{eq:ucc_operators}
\tau_j - \tau^\dagger _j = i \sum_k \hat{P}_{k, j},
\end{equation}
where the subterm $\hat{P}_{k, j}$ is a tensor product of Pauli operators (technically, this term can actually be a sum of mutually commuting Pauli operators, as commuting groups do not need to be Trotterized). Resulting in the following expression of the ansatz:

\begin{equation} \label{eq:ucca_pauli}
U(\vec{t}) = e^{\sum_j \sum_k i t_j  \hat{P}_{k, j}},
\end{equation}

The next step is to convert the UCC ansatz into a series of parametrized quantum gates which can directly be implemented on a quantum computer. A usual step in the process of building the UCC ansatz is to use a Trotter-Suzuki decomposition (a process also referred to as Trotterization) to separate the sum in the exponent of Eq.~(\ref{eq:ucca_pauli}) into a product of exponentials, such that
\begin{equation}
U(\vec{t}) \sim  U_{\text{Trotter}}(\vec{t}) = \left( \prod_{j, k} e^{\frac{i t_j}{\rho}\hat{P}_{k, j}} \right)^\rho.
\end{equation}
The Trotter number $\rho$ defines the precision of the approximation, but also enters as a pre-factor impacting the overall depth of the quantum circuit required for its implementation (technically, $\hat{P}_{k, j}$ can actually be a sum of mutually commuting Pauli operators, as the exponential of a sum of commuting groups does not need to be Trotterized and can be directly converted to a product of exponentials). Assuming $\rho=1$, this reduces Eq.~(\ref{eq:ucca}) to
\begin{equation} \label{eq:pauli_exponential}
U_1(\vec{t}) = \prod_{j, k} e^{\frac{i t_j}{\rho}\hat{P}_{k, j}} .
\end{equation}


This illustrates the basic framework surrounding UCC and its application to VQE \cite{Peruzzo2014, Wecker2015, Romero2019}. The required circuit depth for this version of UCC has been shown to scale polynomially in the system size. More specifically, with $\eta$ the number of electrons and $N$ the number of spin-orbitals, the circuit depth is shown to scale $\mathcal{O}((N - m)^2m)$ for each Trotter step \cite{Lee2019}. It was also numerically shown that a single Trotter step is sufficient for an accurate description of the ground state in simple molecular systems \cite{Barkoutsos2018}, because variational optimization can absorb some of the Trotterization error \cite{OMalley2016, Romero2019} (though it does imply that operator ordering can impact accuracy \cite{Grimsley2019_UCC_Review}, see discussion below for more details). 
The UCC ansatz can also be used in the context of restricted active space methods \cite{Roos1980}, considered in Ref.~\cite{Romero2019}. Finally, it has been shown that operators in the UCC ansatz contribute to the expressibility of the ansatz to different extents, allowing for approaches where some are discarded to increase efficiency \cite{Zhang2021_shallow} (a method similar to what is proposed in ADAPT-VQE \cite{Grimsley2019}, see Sec \ref{sec:adaptive_ansatz}). The remainder of the section covers several extensions which aim at improving both the precision and efficiency of UCC based ansatz.\\

\textbf{Extensions of UCC} \\

\paragraph{Generalized UCC:} The first extension of the UCC theory applied in the context of the VQE is the Generalized UCC (UCCG) \cite{Lee2019}. Unlike conventional CC and UCC which only include excitation operators that correspond to transitions from occupied to virtual orbitals, UCCG is agnostic to the orbital character in the (generally Hartree-Fock) reference state it is applied to. Therefore the single and double excitations in Eq.~(\ref{eq:T_one_body}) and Eq.~(\ref{eq:T_two_body}) are re-written in the context of the UCCGSD \cite{Lee2019} as

\begin{align}
\hat{T}_1 &= \sum_{pq} t_{p}^q\hat{a}^{\dagger}_q \hat{a}_p \label{eq:T_one_body_G} \\
\hat{T}_2 &= \sum_{pqrs} t_{pq}^{rs}\hat{a}^{\dagger}_r \hat{a}^{\dagger}_s \hat{a}_q \hat{a}_p, \label{eq:T_two_body_G}
\end{align}
where we recall that $p$, $q$, $r$, and $s$ are used as indices spanning both occupied and virtual orbitals. Generalized CC, was actively discussed in the conventional computing literature, though a unitary version was only mentioned in \cite{Nooijen2000} and never extensively studied. Lee et al. \cite{Lee2019} provide an in-depth study of the method and showed that the associated UCCGSD ansatz depth scales $\mathcal{O}(N^3)$ in the number of qubits $N$ while at the time providing example showing that this method is more robust to noise and accurate than UCCSD.

\paragraph{Paired UCC (k-UpCCGSD):} A second extension of UCC is the Unitary pair CC with Generalized Singles and Doubles (UpCCGSD) \cite{Lee2019}. This version is based on the paired coupled-cluster method \cite{Stein2014, Limacher2013}. The key difference with CCSD is that it only includes two body terms that move pairs of opposite-spin electrons together from doubly-occupied to fully unoccupied spatial orbitals, ensuring no single occupancy in the described states. Recalling that we use $i$ for an occupied orbital and $a$ for virtual orbitals, the $\hat{T}_2$ terms included in UpCCSD can be described as
\begin{equation} \label{eq:T2_pair_CC}
    \hat{T}_2 = \sum_{ia} t_{i_{\alpha} i_{\beta}}^{a_{\alpha} a_{\beta}}\hat{a}^{\dagger}_{a_{\alpha}} \hat{a}^{\dagger}_{a_{\beta}} \hat{a}_{i_{\beta}} \hat{a}_{i_{\alpha}},
\end{equation}
with $\alpha$ and $\beta$ the spin up and spin down indices. The one body terms remain identical to Eq.~(\ref{eq:T_one_body}). Lee et al. \cite{Lee2019} however showed that using a unitary version of the method failed to achieve chemical accuracy. They therefore adapted it by using generalized one- and two- body excitation (see Eq. \ref{eq:T_one_body_G}) (where the indices are not constrained by whether they are occupied or not) while maintaining the spatial orbital pairing), hence the 'G' in UpCCGSD. They further improved the method by allowing repetitions of the ansatz (the number of repetitions referred to by the $k$ parameter) allowing more flexibility for the wave function. This forms the $k$-UpCCGSD ansatz, which can be described as
\begin{equation} \label{eq:kUpCCGSD}
    \ket{\psi}_{k-UpCCGSD} = \prod_{l=1}^k (e^{\hat{T}^{(l)}} - e^{\hat{T}^{(l)\dagger}}) \ket{\psi_{HF}}.
\end{equation}

The key advantage of this method is to allow a linear scaling ansatz \cite{Lee2019}, namely that the ansatz depth scales as $\mathcal{O}(kN)$ with $N$ the number of spin-orbitals, and a reasonable quadratic scaling in the number of parameters $\mathcal{O}(kN^2)$ \cite{Huggins2020}. In this method, the parameters for each $l$ block of the ansatz are treated independently. A few drawbacks of this method have been raised in Ref. \cite{Grimsley2019_UCC_Review}. In particular, it is shown that while the ansatz error can be arbitrarily reduced by increasing $k$, it also involves a nonlinear increase in the optimization burden due to the energy landscape becoming more complex from adding new parameters. The result found through this ansatz also seems to be dependent on the parameter initialization \cite{Grimsley2019_UCC_Review}.
However, Lee et al. ~\cite{Lee2019} show numerically that k-UpCCGSD finds better energies than UCCSD (also for excited-state calculations, see Sec.~\ref{sec:excited_states}). These results were corroborated in Ref.~\cite{GreeneDiniz2020}, which studies the accuracy of UCC-based ans{\"{a}}tze. 

\paragraph{Pair-natural orbital-UCC (PNO-UpCCGSD):}The idea behind k-UpCCGSD was further extended in Refs.~\cite{Kottmann2021_1, Kottmann2021_2} by restricting excitations to those between pair-natural orbitals (PNO) and the occupied orbitals of the reference state. PNOs are an efficient basis for modeling of the most relevant virtual states for a given occupied orbital pair \cite{Edmiston1968, Ahlrichs1975, Meyer1973, Meyer2009} initially developed for Coupled Electron-Pair Approximations, but subsequently used in CC \cite{Neese2009_1, Neese2009_2}, and found to significantly reduce the size of of the virtual orbital space in CC calculations (for example \cite{Nagy2019}). PNOs are found as the eigenvectors of a pair density matrix, often found from a lower level of theory.

One can define a set of orthonormalized PNOs $\mathcal{S}_{ij}$ from each possible pair $\{i, j\}$ of canonical HF orbitals. The PNO-UpCC(G)SD ansatz is constructed similarly to any UCC ansatz, but only with operators allowing excitations from occupied indices (i.e  $\mathcal{S}_{ii}$) to unoccupied orbitals of the PNO set. It is also possible to extend beyond excitations from a reference orbital to create a generalized version of the ansatz. The single excitation term then allows excitations from any PNO to any PNO. Ref.~\cite{Kottmann2021_1} shows numerically that the PNO method significantly reduces the number of parameters and of CNOT gates compared to k-UpCCGSD (by a factor of $4$ to $8$ in both cases). This method was used to develop an ansatz tractable on conventional computers \cite{Kottmann2021_2}.

\paragraph{OO-UCC:} A third example of an extension of UCC is the Orbital Optimized UCC (OO-UCC) (independently proposed in both Ref.~\cite{Mizukami2020} and Ref.~\cite{Sokolov2020} with minor differences). The logic behind OO-UCC is to optimize the one-body part of the ansatz using conventional computation, as it is a tractable optimization of orbital rotations. In particular, the one-body terms act as orbital rotation on the initial input state (usually the Hartree-Fock wave function), therefore if we start from the UCCSD ansatz and apply and use a single Trotter step approximation ($\rho = 1$) we can write:
\begin{align}
&\ket{\psi}_{UCCSD} = e^{\hat{T}_2+ \hat{T}_1}\ket{\psi_{HF}} \nonumber \\
& \approx e^{\hat{T}_2} e^{\hat{T}_1}\ket{\psi_{HF}}.
\end{align}
With the one body operator only changing the Hartree Fock determinant to another initial wave function determinant, such that $\ket{\psi_{\mathrm{init}}} = e^{\hat{T}_1}\ket{\psi_{HF}} $, we have the OO-UCCD ansatz:
\begin{align}
\ket{\psi}_{OO-UCCD} = e^{\hat{T}_2} \ket{\psi_{\mathrm{init}}}
\end{align}
The one body terms $\hat{T_1}$ are used to optimize single-orbital rotations on a conventional computer, effectively resulting in a change to the orbital definitions on which the VQE is subsequently applied at each step \cite{Mizukami2020, Sokolov2020}. In this way, OO-UCC is bears similarities to multi-configurational self-consistent field (MCSCF) methods, as it requires an iterative optimization of the orbitals on a conventional computer coupled to the VQE on the quantum computer (for MCSCF proposals on a quantum computer see, for instance, Refs.~\cite{Yalouz2021, Tilly2021}). 

Sokolov \textit{et al.} \cite{Sokolov2020} propose two variants of OO-UCC. The first one (OOpUCC) only allows paired excitations in the two-body terms (similar to UpCCGSD \cite{Lee2019}), grounded in the success of the analogous CC method \cite{Bozkaya2011,Bozkaya2013, Stein2014} (and labeled OO-pUCC). The second one adapts the singlet CC method (CCD0) \cite{Bulik2015}, where the two-body excitation operators are split into singlet and triplet terms, and singlet operators are kept in the ansatz. For this variant, Sokolov \textit{et al.} \cite{Sokolov2020} propose to either reduce operators by leveraging index symmetries in singlet terms (OO-UCCD0) or to use the full set of singlet operators (OO-UCCD0-full), akin to the methods proposed in Ref.~\cite{Bulik2015}. Mizukami et al. \cite{Mizukami2020} point out that, while OO-UCC requires more computation than UCC, it trades it off for a simpler quantum circuit, allowing all wave function parameters to be treated fully variationally, and allowing incorporation of correlations outside of the active space with a reduced the number of qubits (as discussed for MCSCF methods in Ref.~\cite{Yalouz2021, Tilly2021}). \\

\paragraph{Downfolded Hamiltonian and Double Unitary Coupled Cluster (DUCC):} Downfolded Hamiltonian methods were initially developed in the context of CC theory and shortly thereafter extended to UCC \cite{Kowalski2018, Bauman2019, Bauman2019_2, Kowalski2020, Kowalski2021}, to reduce the space in which the ansatz is constructed without impacting the quality of the representation (and usually referred to as DUCC formalism). The idea was adapted for implementation as part of VQE using a downfolded Hamiltonian and a Generalized UCC ansatz \cite{Bauman2021} or UCCSD ansatz \cite{Metcalf2020}. Here we report on the construction of the effective Hamiltonian under the DUCC formalism, as any other UCC ansatz one might want to use). To begin with, the clusters usually used in CC theory are split into $\hat{T}_{int}$ and $\hat{T}_{ext}$ which represents excitations within, and outside the target active space respectively \cite{Bauman2019, Bauman2019_2}. Unitary operators are then constructed using the UCC formalism:
\begin{equation}
    \begin{aligned}
        &\hat{\sigma}_{int} = \hat{T}_{int} - \hat{T}^{\dagger}_{int} \\
        &\hat{\sigma}_{ext} = \hat{T}_{ext} - \hat{T}^{\dagger}_{ext}. \\
    \end{aligned}
\end{equation}
The DUCC wavefuncion can be constructed by exponentiation these operators and applying them to a reference state:
\begin{equation}
    \ket{\psi_{DUCC}} = e^{\hat{\sigma}_{ext}}e^{\hat{\sigma}_{int}}\ket{\psi_0}.
\end{equation}
The part of the ansatz external to the  target active space (or the part that one aims to fold into the effective active space Hamiltonian) is then absorbed into the Hamiltonian giving the following operator $\hat{H}_{ext}^{DUCC} = (e^{\hat{\sigma_{ext}}})^{\dagger} \hat{H}e^{\hat{\sigma_{ext}}}$. Because the external operators represent higher energy excitations, they can be approximated without signficant loss in accuracy \cite{Metcalf2020, Bauman2019}. The downfolded Hamiltonian can be constructed in the active space by defining a projector on the reference state $\hat{P}$ and on the orthogonal determinants of the target active space $\hat{Q}_{int}$ such that: $\hat{H}_{ext}^{eff-DUCC} = (P + Q_{int})\hat{H}_{ext}^{DUCC}(P + Q_{int})$. The DUCC wavefunction can then be written as
\begin{equation}
    \ket{\psi_{DUCC}} = Ee^{\hat{\sigma}_{int}}\ket{\psi_0},
\end{equation}
with the remaining internal excitations being implemented using a UCC ansatz and trained with VQE \cite{Metcalf2020, Bauman2021}. 

The method was shown to recover a large proportion of correlation energy on several small molecules while saving significant quantum resources \cite{Metcalf2020}. In Ref.~\cite{Bauman2021}, Bauman et al. also show that using UCCGSD provides a material improvement over using UCCSD in this context, bringing results close to FCI on $\mathrm{H_2O}$, of course at the cost of additional parameters from the Generalized UCC.  

\paragraph{Other UCC-based methods:} Several other extensions of UCC are also worth mentioning briefly. The Unitary Cluster-Jastrow \cite{Matsuzawa2020} ansatz uses Jastrow factors, traditionally used in Quantum Monte Carlo \cite{Foulkes2001} to include the impact of cusps from the Coulomb potential in the wavefunction and adapted for CC theory in \cite{Neuscamman2013}. The method shows similar scaling to k-UpCCGSD and excellent results in numerical analysis \cite{Matsuzawa2020}. It also does not require trotterization and thereby is less prone to errors due to operator ordering \cite{Grimsley2019_UCC_Review}). The multicomponent UCC \cite{Pavosevic2018}  extends the UCC ansatz to systems that include coupling to bosonic statistic modes. It was also applied to photon number states to cover polaritonic chemistry \cite{Pavosevic2021}. Finally, the Low Depth Circuit Ansatz (LDCA) \cite{Dallaire2019} is grounded in the Bogoliubov (or quasi-particle) CC \cite{Stolarczyk2010, Rolik2014, Signoracci2015}, for which a unitary version was developed in Ref.~\cite{Dallaire2019}. While the Bogoliubov UCC can be implemented as an ansatz for VQE, Dallaire et al. \cite{Dallaire2019} propose some additional transformations to exactly parametrize the ansatz in a linear depth circuit (but with quadratic parameter scaling). The parameter-efficient circuit training (PECT) optimizer proposer in Ref.~\cite{Sim2021}, appears to provide an effective method to optimize LDCA on larger systems. \\
\\

\paragraph{Unitary Selective Coupled-Cluster Method:} The USCC method, proposed by Fedorov \textit{et al.} \cite{Fedorov2022} could be categorized both as a UCC extension and as an adaptive ansatz. To implement this method, one starts with the reference Hartree-Fock state. From there, one and two body excitations (from occupied to unoccupied orbitals) which have corresponding Hamiltonian matrix elements above a given threshold $\tau_1$ are included in the ansatz. A VQE is then performed on this ansatz until convergence - the first iteration of the method is complete. For the following iterations, the threshold is update such that: $\tau_i = \tau_{i-1} / 2$, and new, higher order excitations are generated by applying one and two body excitations to those already included in the ansatz. The metric to compare to the threshold for inclusion of these excitations is obtained by multiplying the parameters obtained after optimization at the previous step with the Hamiltonian matrix element corresponding to the single or double excitation added. As per previous iterations, coefficients that are above the threshold are included in the ansatz and then optimized through VQE.
The optimization continues until a convergence criteria is met or sufficient excitations have been included. Fedorov \textit{et al.} \cite{Fedorov2022} note that the method does not provide a wavefunction form that is as compact as can be achieved through ADAPT-VQE, but is likely to require significantly less measurements to perform and converge. It is worth noting that as an adaptive method USCC would likely also present some resilience to the barren plateau problem. 

\textbf{UCC discussion}\\

Overall, it is clear that there are several advantages of using UCC-type ansatz compared to HEA. First and foremost, the number of parameters in the former, ranging from $\mathcal{O}(N^3)$ to $\mathcal{O}(kN^2)$ ($k$ an arbitrary constant) is significantly more advantageous than in the HEA which spans a much wider part of the Hilbert space. It was also shown numerically that the UCC ansatz can provide exact parametrization for an arbitrary electronic wavefunction \cite{Evangelista2019}, subject to certain conditions on optimization. The accuracy of the family of ansatz and its ability to approach FCI level results on a variety of small systems was numerically established in Ref.~\cite{GreeneDiniz2020} (namely $\mathrm{H_2}$, $\mathrm{H_3}$, $\mathrm{H_4}$, $\mathrm{NH}$, $\mathrm{OH^{+}}$, $\mathrm{CH_2}$, $\mathrm{NH_2^+}$). Similarly, Ref.~\cite{Sokolov2020} establishes that UCCSD outperforms conventional CCSD methods in accuracy on $\mathrm{H_4}$, $\mathrm{H_2O}$, $\mathrm{N_4}$ and on the one-dimensional Fermi-Hubbard model. It is further shown in the same study that orbital optimized methods (namely p-OO-UCCSD, OO-UCCD0 and OO-UCCD0-full) achieve results within $10$ to $20$ mH, showing a minor loss in accuracy compared to UCCSD, but a significant reduction in quantum resources required.

A clear drawback of UCC-type ans{\"{a}}tze is specifically that these are not hardware efficient. All UCC ans\"atze are designed in a manner that is agnostic to the connectivity of the device. The number of CNOT gates for each of the exponentiated Pauli strings required in the ansatz scales with its Pauli weight $q$ (number of non-identity operators in the string) when full connectivity is allowed. Namely, each Pauli strings exponential requires $2(q - 1)$ CNOT gates \cite{nielsenQuantumComputationQuantum2010}. Assuming double excitations are used, this implies a scaling of $\mathcal{O}(2N^4(\tilde{q} -1))$ CNOT gates (with $\tilde{q}$ the average Pauli weight across all strings) if no further action is taken to make the ansatz more efficient (some of these gates can be canceled out at compilation). However, a significant overhead in the number of CNOT gates is required if connectivity is limited to bridge entanglement between qubits that are not directly connected on the device. Connectivity limitation of the qubit register can be addressed by introducing SWAP networks to effectively relocate qubits together when $q$-qubit operators need to be implemented on a non-local set of qubits \cite{OGorman2019}. This allows maintaining the depth scaling of UCC ans\"atze by parallelizing on a single qubit register several operators that would otherwise not commute, irrelevant of the degree of connectivity of the device. It does however come at the cost of additional SWAP (or CNOT) gates required to build the SWAP network compared to a fully connected device. This is also related to a similar drawback of UCC: while the scaling is advantageous, the ansatz generally requires a very large pre-factor in the number of gates \cite{Grimsley2019_UCC_Review, Romero2019, Choquette2021}. A similar method to construct a more efficient gate fabric, but with the added benefit of preserving quantum number symmetry is found in Ref.~\cite{Anselmetti2021}. 

Overall, the UCC ans\"atze has a large pre-factor for the depth and number of entangling gates. As an example, Ref.~\cite{Choquette2021} show that to achieve similar accuracy on a $12$-qubit version of $\mathrm{H_2O}$, UCCSD requires $528$ entangling gates, hence at the very best a depth of about $100$ as one can fit at most $6$ entangling gates in one time step, against $88$ entangling gates for HEA, or a circuit depth of about $40$ (In Ref.~\cite{Choquette2021}, Choquette et al. also present an ansatz which extends the Hamiltonian Variational Ansatz presented in the following section, and which requires $108$ CNOT gates for the same molecular model). It is fair to assume that k-UpCCGSD would perform significantly better than UCCSD in terms of depth. The Qubit-excitations \cite{Xia2020, Yordanov2020_QE, Yordanov2021}, and qubit-operators \cite{Ryabinkin2018, Ryabinkin2020, Tang2021} Coupled Cluster based ansatz (see Sec. \ref{sec:adaptive_ansatz}), are a potential answer to address the scaling of CNOT gates while preserving some of the benefits of UCC ans{\"{a}}tze. 

Another point worth mentioning about UCC-based ans\"atz is their dependence on operator ordering \cite{Grimsley2019_UCC_Review, Izmaylov2020b}. Ordering of fermionic operators within the ansatz significantly impacts its accuracy, in particular for highly correlated electron wave functions (which is, as Grimsley et al. \cite{Grimsley2019_UCC_Review} and Wecker et al. \cite{Wecker2015} point out, the primary target of interest for quantum computers, as low correlation wave functions can easily be treated with conventional methods - see Sec. \ref{sec:vqe_vs_conventional}). This is particularly noticeable when dissociation limits are approached \cite{Grimsley2019_UCC_Review, Matsuzawa2020}, but can be in great part addressed by repeating the ansatz (i.e. setting $k$ to a higher number for k-UpCCGSD). As pointed out in Ref.~\cite{Lee2019} and corroborated by results from Ref.~\cite{Grimsley2019_UCC_Review}, k-UpCCGSD does appear to be largely resilient to problems of operator order as long as one allows for $k$ to be sufficiently high to provide the variational flexibility needed. 

Finally, another issue that can happen in both HEA and UCC ansatz is the appearance of 'kinks' in the Potential Energy Surface (PES). While already apparent in Ref.~\cite{Kandala2017}, these are very well characterized in Ref.~\cite{Ryabinkin2019}. These kinks are due to the energy ordering of the electronic states and lack of preservation of certain of symmetries (e.g. electron number, total spin) when building the ansatz, and can be addressed using symmetry preserving methods, including as an additional constraint placed in the VQE cost function \cite{Ryabinkin2019} (see Sec. \ref{sec:cost_function}).

\subsubsection{Symmetry-preserving methods} \label{sec:symmetry_preserving_methods}

A proposed solution to a common pitfall of HEA and UCC, is to build the ansatz in a manner that preserves certain symmetries of the system studied (though it is worth noting that UCC ans\"tze in general preserve particle number symmetry). There are two main benefits related to this:
\begin{itemize}
    \item It restricts the size of the Hilbert space in which the ground state can be searched while remaining largely agnostic to the system studied, potentially speeding up the optimization and reducing the risk of barren plateaus.
    \item It avoids risks of localized inaccuracies that have been observed as 'kinks' in the dissociation curves of molecules studied \cite{Kandala2017}, and that are related to local minima states with a different number of electrons \cite{Ryabinkin2019}
\end{itemize}

It is worth pointing out that symmetry preservation can also be achieved using an adjustment to the cost function \cite{mccleanTheoryVariationalHybrid2015, Ryabinkin2019} (further details are presented in Sec. \ref{sec:cost_function}), and can be used as error mitigation method (see Sec. \ref{sec:mit-symmetry-verification}).

The core objective of symmetry-preserving ans{\"{a}}tze in general, is the preservation of the electron number in the modeled wave function. A common theme in these methods is the use of exchange-type gates (or iSWAP gates)  (for a description and hardware implementation of these gates, we refer readers to Refs.~\cite{Roth2018, Egger2019}). These two-qubit gates aim at allowing relative phase changes between superpositions of $\ket{01}$ and $\ket{10}$ states, while leaving $\ket{00}$ and $\ket{11}$ unchanged. In the context of a VQE ansatz, their use can therefore never alter the number of occupied orbitals in the modelled wave-function.

There exist two published versions of this type of gate. The most commonly used one is a two-parameter version, originating from Ref.~\cite{Egger2019}, which allows further flexibility in the output wavefunction:

	\begin{equation} \label{eq:two_param_xchange_gate}
     A(\theta, \phi) =
        \begin{pmatrix}
        1& 0 & 0 & 0 \\
        0 & \cos\theta & e^{i\phi}\sin\theta & 0\\
        0 & e^{-i\phi}\sin\theta & -\cos\theta  & 0 \\
        0 & 0 & 0 & 1
        \end{pmatrix}.
	\end{equation}

It can be obtained with a quantum circuit composed of three CNOT gates and two rotation gates, as presented in Fig. \ref{fig:A_gate},

\begin{figure}[ht]
\centerline{
    $$
    \Qcircuit @C=1em @!R {
    & \targ     & \qw                               & \ctrl{1}& \qw                    & \targ     & \qw \\
    & \ctrl{-1} & \gate{R(\theta, \phi)^{\dagger}}  & \targ   & \gate{R(\theta, \phi)} & \ctrl{-1} & \qw   \\
    }
    $$
    } \caption{Quantum circuit for realization of gate $A(\theta, \phi)$, Eq.~(\ref{eq:two_param_xchange_gate}). With $R(\theta, \phi) = R_z(\phi + \pi)R_y(\theta + \pi/2) $.} \label{fig:A_gate}
\end{figure}

A special, single parameter version of this gate has also been presented (see Refs.~\cite{McKay2016, Sagastizabal2019})

\begin{equation}\label{eq:one_param_xchange_gate}
    A(\theta) =
    \begin{pmatrix}
    1& 0 & 0 & 0 \\
    0 & \cos2\theta & -i\sin2\theta & 0\\
    0 & -i\sin2\theta & \cos2\theta  & 0 \\
    0 & 0 & 0 & 1
    \end{pmatrix}
\end{equation}

It is worth noting that this approach to particle conservation in the wave function is only valid when considering certain types of fermion-to-spin mappings (see Sec.~\ref{sec:Encoding}). In particular, while these gates necessarily preserve the number of excited qubits under Jordan-Wigner \cite{Gard2020} and the Parity mappings, it is easy to see that it does not under Bravyi-Kitaev, as swapping an excited qubit with a non-excited qubit across two blocks could require changing the state of all the subsequent `parity' encoding qubits within a block (see Sec.~\ref{sec:bravyi-kitaev}).

A first relevant use case is presented in Ref. \cite{Barkoutsos2018}, where the HEA (Sec.~\ref{sec:HEA}) is adapted to preserve the particle number. The method transforms the HEA into the particle/hole representation of the Hamiltonian (see Sec. \ref{sec:Hamiltonian_representation}). The ansatz in Ref.~\cite{Barkoutsos2018} is structured like the HEA, with a series of single-qubit rotations and entangling blocks, similar to that presented in Eq.~(\ref{eq:HEA_unitaries}). Each constituent block however can be composed of interlaced exchange-conserving gates, and as these are parametrized, the rotation unitaries can be absorbed in the entangling unitaries.

Two versions are proposed in Ref.~\cite{Barkoutsos2018}. The first one makes use of the two-parameter exchange-conserving gate (Eq. \ref{eq:two_param_xchange_gate}), as presented in Fig. \ref{fig:circuit_for_two_param_sym}, the second one relies on the one-parameter exchange-conserving gate (Eq. \ref{eq:one_param_xchange_gate}), as presented in Fig.\ref{fig:circuit_for_one_param_sym} (note these require additional rotation gates in each block). Barkoutsos et al. \cite{Barkoutsos2018} also provide a comparison of these two approaches against a more typical HEA method (where the entangling block is composed of a ladder of CNOT gates), and show numerically that particle conserving blocks achieve better accuracy when computing the dissociation curve of $\mathrm{H_2O}$ (with a slight advantage for the two-parameters gates). This approach is further studied and tested successfully on a superconducting quantum device in Ref. \cite{Ganzhorn2019}.

\begin{figure}[ht]
\centerline{
\Qcircuit @C=1em @!R {
   \lstick{\ket{0}}   &   \qw   &   \multigate{1}{~A(\theta, \phi)~}   & \qw & \qw                              & \qw          \\
   \lstick{\ket{0}}   &   \qw   &   \ghost{~A(\theta, \phi)~}          & \qw & \multigate{1}{~A(\theta, \phi)~} & \qw                     \\
   \lstick{\ket{...}} &   \qw   &   \multigate{1}{~A(\theta, \phi)~}   & \qw & \ghost{~A(\theta, \phi)~}        & \qw \\
   \lstick{\ket{1}}   &   \qw   &   \ghost{~A(\theta, \phi)~}          & \qw & \multigate{1}{~A(\theta, \phi)~} & \qw                     \\
   \lstick{\ket{1}}   &   \qw   &   \qw                                & \qw & \ghost{~A(\theta, \phi)~}        & \qw \\
}} \caption{Single layer of symmetry preserving ansatz presented in Ref. \cite{Barkoutsos2018}, based in two-parameters exchange conserving gates $A(\theta, \phi)$, Eq.~(\ref{eq:two_param_xchange_gate})} \label{fig:circuit_for_two_param_sym}

\end{figure}

\begin{figure}[ht]
\centerline{
\Qcircuit @C=1em @!R {
   \lstick{\ket{0}}   &   \qw   &   \gate{Rz(\phi_N)}      &   \qw   &   \multigate{1}{~A(\theta)~}   & \qw & \qw                        & \qw \\
   \lstick{\ket{0}}   &   \qw   &   \gate{Rz(\phi_{N-1})}  &   \qw   &   \ghost{~A(\theta)~}          & \qw & \multigate{1}{~A(\theta)~} & \qw \\
   \lstick{\ket{...}} &   \qw   &   \gate{Rz(\phi_{...})} &   \qw   &   \multigate{1}{~A(\theta)~}   & \qw & \ghost{~A(\theta)~}        & \qw \\
   \lstick{\ket{1}}   &   \qw   &   \gate{Rz(\phi_2)}      &   \qw   &   \ghost{~A(\theta)~}          & \qw & \multigate{1}{~A(\theta)~} & \qw \\
   \lstick{\ket{1}}   &   \qw   &   \gate{Rz(\phi_1)}      &   \qw   &   \qw                          & \qw & \ghost{~A(\theta)~}        & \qw \\
}}\caption{Single layer of symmetry preserving ansatz presented in Ref. \cite{Barkoutsos2018}, based in one-parameters exchange conserving gates $A(\theta)$, Eq. \ref{eq:one_param_xchange_gate}.} \label{fig:circuit_for_one_param_sym}

\end{figure}

In Ref. \cite{Gard2020}, Gard et al. propose to address the wider set of symmetries (particle number, time reversal, total spin, spin magnetization) by creating an Efficient Symmetry-Preserving (ESP) ansatz for VQE. It uses the same two-parameters exchange-conserving building blocks as in Ref.~\cite{Barkoutsos2018} and a very similar structure to Fig. \ref{fig:circuit_for_two_param_sym} with some optimization. The idea behind this ansatz is to build a structure that spans the largest part of the Hilbert space while constraining symmetries as much as possible. As such, it is more efficient than HEA, but is less restrictive than UCC, guaranteeing that the ground state is indeed in the spanned Hilbert space \cite{Gard2020}. In that respect, we consider that this is the VQE ansatz that is closest to providing the span of FCI (see Sec. \ref{sec:full_configuration_interaction}).

This ansatz can be systematically built by first applying X gates to a number of qubits equal to the number of electrons in the problem considered. For efficient circuit building, and unlike in Ref.~\cite{Barkoutsos2018}, Gard et al. \cite{Gard2020} advise that one must avoid placing these as neighboring qubits. Following this, one can apply A gates to each pair of $\ket{1}$ and  $\ket{0}$ zero qubits, and subsequently, apply additional A gates to span the complete register and until $\binom{N}{m}$ A gates have been placed ($N$ the number of orbitals or number of qubits, $m$ the number of electrons). We have reproduced an example initially presented in \cite{Gard2020} for $N=4$ and $m=2$ in Fig. \ref{fig:ESP_4_2}.

\begin{figure*}[ht]
\centerline{
\Qcircuit @C=1em @!R {
   \lstick{\ket{0}} & \qw      & \multigate{1}{~A(\theta_1, \phi_1)~} & \qw                                  & \multigate{1}{~A(\theta_4, \phi_4)~} & \qw                                  & \meter  \\
   \lstick{\ket{0}} & \gate{X} & \ghost{~A(\theta_1, \phi_1)~}        & \multigate{1}{~A(\theta_3, \phi_1)~} & \ghost{~A(\theta_4, \phi_4)~}        & \multigate{1}{~A(\theta_6, \phi_6)~} & \meter \\
   \lstick{\ket{0}} & \gate{X} & \multigate{1}{~A(\theta_2, \phi_1)~} & \ghost{~A(\theta_3, \phi_1)~}        & \multigate{1}{~A(\theta_5, \phi_5)~} & \ghost{~A(\theta_6, \phi_6)~}        & \meter  \\
   \lstick{\ket{0}} & \qw      & \ghost{~A(\theta_2, \phi_1)~}        & \qw                                  & \ghost{~A(\theta_5, \phi_5)~}        & \qw                                  & \meter \\
}} \caption{Example of the ESP ansatz construction for $N= 4$ and $m=2$, as presented in \cite{Gard2020}, based on two-parameters exchange-conserving $A(\theta, \phi)$ gates, Eq.~(\ref{eq:two_param_xchange_gate}). The first three $\phi_i$ parameters are set to be equal as the number of optimal parameters has already be reached in the ansatz and further flexibility is not required} \label{fig:ESP_4_2}
\end{figure*}

The optimal number of parameters to allow full parametrization of the Hilbert space, given particle-conserving symmetry can be derived from the number of complex coefficients required to span the subspace drawn by a given Hamiltonian, Gard et al. \cite{Gard2020} show that this number is $2\binom{N}{m} - 2$. Given there are $2\binom{N}{m}$ parameters in the ESP ansatz as described above, the optimal number can be obtained by setting two of the $\phi_i$ equal to a third one, as shown in Fig. \ref{fig:ESP_4_2}. They also point out that the method for constructing the ansatz is neither unique nor optimal in terms of the number of entangling gates and as such, further research may help extend the symmetry preserving ansatz (for instance by including ansatz options for fully-connected machines). Other symmetries can be imposed as follows:
\begin{itemize}
    \item Time reversal symmetry can be imposed by setting all $\phi_i$ to zero, resulting in the number of parameters scaling $\binom{N}{m}$
    \item Spin symmetries require to first order the qubit such that the first half of the register represents spin up orbitals, and the second half spin down orbitals (which requires some fermion to spin mapping modifications). The ladder structure described for the ESP ansatz is maintained, with a difference that any $A$ gate that links the first and second half of the register has parameters set to $0$ (or is removed), preventing swaps of electrons from spin-up to spin-down orbitals (and vice versa), and enforcing spin symmetry.
\end{itemize}

Based on this construction, the number of CNOTs scales at most as $3\binom{N}{m}$(without further optimization and compilation of the ansatz). This implies that it goes from linear if $m=1$, or $m=N-1$ to exponential if $m \sim N/2$. It can be slightly reduced using some of the symmetries mentioned above, however it remains significantly less efficient than UCC based ansatz in particular in terms of parameters, due to a larger span of the Hilbert space.

As such, we find that the cost of ESP (and other symmetry preserving ansatz) is too prohibitive to be implemented in cases where $m \sim N$. There could be scope for these ans{\"{a}}tze to outperform the likes of UCC type ans{\"{a}}tze when the problem can be treated accurately with $m$ being negligible or close to $N$. An interesting research question would be to study this ansatz in a plane wave basis where the number of basis functions (and therefore qubits) required for each electron to treat the system accurately can be extremely large \cite{Babbush2018}.

\subsubsection{The Hamiltonian Variational Ansatz and extensions} \label{sec:hva}

\paragraph{The Hamiltonian Variational Ansatz (HVA):} this ansatz was initially presented in Refs. \cite{Wecker2015, Wiersema2020}, and is inspired from the quantum approximate optimization algorithm (QAOA) ansatz \cite{Farhi2014} which draws from ideas developed for adiabatic quantum computation \cite{Farhi2000}. The first step in building this ansatz is to decompose the Hamiltonian into a sum of non-commuting operators:

\begin{equation}
    \hat{H} = \sum_a \hat{h}_a,
\end{equation}

where $[\hat{h}_i, \hat{h}_j] \neq 0$. These terms are used alternatively over $L$ layers to evolve an initial state $\ket{\psi_0}$.

\begin{equation}
    \ket{\psi_L} = \prod_{l=1}^L \left( \prod_a e^{-i \theta_{a, l} \hat{h}_a} \right) \ket{\psi_0}.
\end{equation}

The initial state $\ket{\psi_0}$ is picked as the ground state of any of the $\hat{h}_a$, except for the first one acting on it. There are a few points to note about this ansatz. The first one is that for a single repetition of the ansatz it has a number of variational parameters lower than the UCCSD ansatz, because there is only one parameter per commutative group in the Hamiltonian (we have seen in Sec. \ref{sec:Grouping}, that $N^3$ commutative group is a reasonable estimate for \textit{ab initio} molecular systems, though it could be much lower for lattice models). This means that layer repetitions is likely to be required to achieve the same level of expressibility, although exact scaling is not known. In Ref.~\cite{Wecker2015}, Wecker et al. suggest that the ansatz is trained layer-by-layer to facilitate optimization. The scaling in the number of entangling gates is similar to UCC based ansatz, as approximately the same number of operators are incorporated for each repeated layer. This also implies a similar depth scaling.

The HVA was shown however to be particularly well suited for models of many-body physics\cite{Wiersema2020}. Key points revealed in this study include the fact that the ansatz appears to exhibit strong resilience to barren plateaus, and that layer repetitions allow for over-parametrization of the ansatz and therefore smoothing out of the energy landscape to avoid local minima. It is clear that low Pauli-weight mapping (or lattice models) significantly improves the algorithm. The ansatz was also adapted to solve the Heisenberg antiferromagnetic model on the Kagome lattice in Refs. \cite{kattemolle2021variational, bosse2021probing}, both study showing promising results. In particular, Ref. \cite{kattemolle2021variational} shows that VQE approaches the true ground of the lattice exponentially as a function of circuit depth on a noiseless simulation of up to 20 sites. Bosse and Montanaro~\cite{bosse2021probing} find a similar result ton a simulation of 24 sites, though point out to the large number of variational parameters needed. Another adaptation of HVA to the Heisenberg model, accompanied by a scaling study is presented in Ref. \cite{Jattana2022}. Finally, a version of HVA for Fermi-Hubbard is studied by Stanisic \textit{et al.} \cite{Stanisic2021}, in which the ansatz is created by first applying a number of Givens rotations (rotation in a two dimensional subspace of the Hilbert space, which can be used as partial excitation exchanges between two qubits), allowing to efficiently prepare the ground state of the non-interacting Fermi-Hubbard model \cite{Jiang2018}, then followed by time evolution following the same logic as HVA. The paper shows that through this ansatz construction, few parameters are needed to reproduce key qualitative features of strongly-correlated electronic systems. 

\paragraph{Fourier-transform HVA \cite{Babbush2018}:} This ansatz was initially developed as a linear scaling method to variationally model the ground state of jellium (uniform electron gas). In this context, it was developed using a plane wave basis, allowing the one-body hamiltonian of jellium to be diagonal \cite{Babbush2018}. A slightly more general formulation is presented in Ref.~\cite{Choquette2021}. The method relies on the fermionic fast Fourier transform (FFFT) \cite{Verstraete2009, Ferris2014, Jiang2018} which was initially constructed to diagonalize dynamics in many-body systems, and which has been shown to have a depth scaling of $\mathcal{O}(N)$ if implemented on a planar lattice of qubits \cite{Babbush2018}. To construct this ansatz one must first separate the Hamiltonian into kinetic and potential energy terms, $\hat{H} = \hat{T} + \hat{V}$ (as presented in Sec. \ref{sec:Hamiltonian_representation}). The ansatz is then constructed in a manner similar to HVA, but applying FFFT to the kinetic energy term: 

\begin{equation}
    U(\boldsymbol{\theta}) = \prod_{l=1}^L \mathrm{FFFT}^{\dagger}\left( \prod_a e^{-i \theta_{a, l}^{(T)} \hat{T}_a} \right) \mathrm{FFFT} \left( \prod_b e^{-i \theta_{b, l}^{(V)} \hat{V}_b} \right) 
\end{equation}
with $\hat{T} = \sum_a \hat{T}_a$ and $\hat{V} = \sum_b \hat{V}_b$. In Ref.~\cite{Babbush2018}, Babbush et al. recommend to use $\ket{\psi_0} = \mathrm{FFFT} \ket{0}$ as initial state, as this makes $\ket{\psi_0}$ an eigenstate of $\hat{T}$ in the plane wave basis. They also suggest absorbing the component of the ansatz corresponding to $\hat{T}$ in the Hamiltonian as it can be done efficiently. It is worth noting that given use of a plane wave basis, for jellium, the operators of $\hat{V}$ are mapped to diagonal $Z$ operators using Jordan-Wigner, which provides a very convenient and compact ansatz scaling $\mathcal{O}(LN)$ on planar qubit lattices, and which can also be optimized layerwise \cite{Wecker2015, Babbush2018}. To the best of our knowledge, this ansatz has not been benchmarked or tested on alternative systems.

\paragraph{Symmetry breaking HVA \cite{Vogt2020, Choquette2021}:} The salient feature of this type of ans{\"{a}}tze is that it incorporates unitaries into the HVA to purposefully break symmetries, to allow for a better optimization path. Both the quantum-optimal-control-inspired ans{\"{a}}tze (QOCA) \cite{Choquette2021}, and the Variational Extended Hamiltonian Ansatz (VEVA) \cite{Vogt2020} are nearly identical and were initially published at the same time. 
The version presented in Ref.~\cite{Choquette2021} is motivated by optimal control theory \cite{Werschnik2007, Alessandro2007}. Quantum optimal control (QOC) is concerned about the efficient design of control pulses to manipulate a quantum system (for a recent review of QOC, we refer reader to M{\"{u}}ller \textit{et al.} \cite{Muller2021}). QOC theory relies on a control Hamiltonian which is composed of a set of drive terms $\{\hat{H}_b\}$, and a drift term $\hat{H}_0$, such that $\hat{H}^{(ctrl)}(t) = \hat{H}_0 + \sum_b c_b(t) \hat{H}_b$ (where $\{c_b(t)\}$ are time-dependent parameters). To build QOCA or VEHA, one must first create a Hamiltonian incorporating the structure of the control Hamiltonian:

\begin{equation}
    \hat{H}_{tot}(t) = \hat{H} + \sum_b c_b(t) \hat{H}_b^{(ctrl)}
\end{equation}
where $\hat{H}$ is the problem Hamiltonian. The ansatz is constructed from this Hamiltonian in a manner similar to HVA, thereby mimicking the time evolution of QOC. It can therefore be constructed as:

\begin{equation}
    U(\boldsymbol{\theta}, \boldsymbol{\phi}) = \prod_{l=1}^L \left( \prod_a e^{-i \theta_{a, l} \hat{H}_a} \right) \left( \prod_b e^{-i \phi_{b, l} \hat{H}^{(ctrl)}_b} \right) 
\end{equation}
where $\hat{H} = \sum_a \hat{H}_a$ and $\hat{H}^{(crtl)}_b$ are a set of drive terms selected for the purpose of the problem studied ($\boldsymbol{\phi}$ corresponds to the parameters $\{c_b(t)\}$). Following the description in Ref.~\cite{Choquette2021}, the problem Hamiltonian is used to explore the symmetry subspace of the Hilbert space, and the drive terms are used to provide shortcuts through the subspaces to increase efficiency. It is recommended in Ref.~\cite{Choquette2021} that the drive terms do not commute with $\hat{H}$. Choquette et al. suggest that this terms could be selected adaptively (akin to adaptive ans{\"{a}}tze described in Sec. \ref{sec:adaptive_ansatz}), but also provide a method to identify the most relevant drive operators. 

This method is applied to the Fermi-Hubbard model and compared to FT-HVA and HVA in Ref.~\cite{Choquette2021}. Results show excellent fidelities achieved with a reasonable number of entangling gates up to 12 qubits (which could also suggest some degree of resilience to barren plateaus). The method is also shown to perform well on a 12-qubit version of $\mathrm{H_2O}$, with fewer numbers of entangling gates compared to UCCSD, albeit a higher number of parameters \cite{Choquette2021}. The method is also tested on the Hubbard model in Ref.~\cite{Vogt2020}, with the stability of the ansatz being very much dependent on the problem parameters. Vogt et al. \cite{Vogt2020} extend the idea of the symmetry breaking HVA by adding classical mean-field parametrization to the ansatz (a method named Variational Mean Field Hamiltonian Ansatz, or VMFHA), which performs better where the VEHA fails. 

\subsection{Adaptative structure ans{\"{a}}tze}  \label{sec:adaptive_ansatz}

Adaptative structure ans{\"{a}}tze aim at creating a circuit structure tailored to the problem studied. As such, they all function similarly, in which the ansatz is grown iteratively throughout the optimization process by adding new operators at each step based on their contribution to the overall energy (or other metric). We distinguish three types of adaptive ansatz, those that grow the quantum circuit iteratively (Sec. \ref{sec:adapt-vqe}), those that incorporate (at least part of) the ansatz into the Hamiltonian by 'dressing' it (Sec. \ref{sec:Hamiltonian_dressing}), and those that variationally update the gate structure of the entire ansatz (Sec. \ref{sec:gate_structure_optimization}). At this point, it is challenging to build comparative metrics for adaptive ans\"atze reliably, and as such we do not provide a comparative table as we have done in other sections. Instead, we direct readers to the qualitative discussion at the end of this section. 

\subsubsection{Iterative ansatz growth methods (ADAPT-VQE and extentions)} \label{sec:adapt-vqe}

\paragraph{Fermionic-ADAPT-VQE:} The idea behind ADAPT-VQE \cite{Grimsley2019} is to progressively build the ansatz by sequentially incorporating into it the operators that contribute most to lowering the VQE energy towards the ground energy. Starting from an initial state (usually the Hartree-Fock wave function, and given a pool of operators $\{\hat{A}_i \}$ the ADAPT-VQE ansatz evolves as follows, with the iteration number as superscripts:
\begin{align} \label{eq:adapt-vqe}
    &\ket{\psi^{(0)}} = \ket{\psi_{HF}} \nonumber \\
    &\ket{\psi^{(1)}} = e^{\theta_1\hat{A}_1}\ket{\psi_{HF}} \nonumber \\
    &\ket{\psi^{(2)}} = e^{\theta_2\hat{A}_2}e^{\theta_1\hat{A}_1}\ket{\psi_{HF}} \nonumber \\
    &... \nonumber \\
    &\ket{\psi^{(k)}} = \prod^1_{i=k} e^{\theta_i\hat{A}_i}\ket{\psi_{HF}}.
\end{align}

The operators in the pool are similar to those produced as part of the UCC ansatz (see Eq. \ref{eq:ucc_operators}), however rather than specifying a number of possible excitation, one can include any one-, two body- or even higher body operator that is believed to be particularly relevant for the system considered: $\hat{A}_m \in \{ (\hat{\tau}_p^q - (\hat{\tau}_{p}^{q})^{\dagger}), (\hat{\tau}_{pq}^{rs} - (\hat{\tau}_{pq}^{rs})^{\dagger}), (\hat{\tau}_{pqr}^{stu} - (\hat{\tau}_{pqr}^{stu})^{\dagger}), ... \} $.

To decide on which operator to incorporate, Grimsley et al \cite{Grimsley2019} recommend choosing the one which results in the highest gradient of the energy functional with respect to the operator parameter. After initializing all operator parameters to $0$, to guarantee that they initially act as the identity operator, gradients can be simply computed as:

\begin{equation} \label{eq:adapt_vqe_grad}
    \frac{\partial E^{(k)}}{\partial \theta_i} = \bra{\psi^{(k)}} [ \hat{H}, \hat{A}_i] \ket{\psi^{(k)}}.
\end{equation}
Once an operator has been selected, and incorporated into the ansatz, a full VQE optimization is completed until parameters all parameters are at their optimum. This implies that at the next operator selection step, all existing $\theta_j$ are such that $\partial E^{(k - 1)}/\partial \theta_j = 0$, enforcing the results of Eq.~(\ref{eq:adapt_vqe_grad}) for all $\theta_i$ corresponding to new operators in following iterations.

The simplicity of the gradient computation at all iterations of ADAPT-VQE is key to its efficiency. However, assuming the case of a second-quantized electronic structure Hamiltonian (with $\mathcal{O}(N^4)$ terms), and given there are $\mathcal{O}(N^4)$ terms in a complete pool for up to double excitation operators, measurement scaling at each outer-loop iteration could naively reach $\mathcal{O}(N^8)$. This can be reduced to $\mathcal{O}(N^6)$ if one reformulates the energy gradients in terms of the three-body reduced density matrix \cite{Liu2021_adapt}. This method also allow predicting gradients from the two-body reduced density matrix of the previous iteration of ADAPT-VQE, reducing overall scaling of measurements back to $\mathcal{O}(N^4)$ albeit at a cost to accuracy.

Therefore, an important research question surrounding ADAPT-VQE is the optimal size of the operator pool, as it determines the number of iterations required, and the complexity of each step.
It is also important to note that the scaling of the ADAPT-VQE pool can also be adjusted the same way it is adjusted in certain variations of the UCC ansatz. For instance, one could restrict operator availability to those available in k-UpCCGSD \cite{Lee2019}, or proceed to only integrate double excitation operator on the quantum computer subroutine akin to the OO-UCC ansatz \cite{Kottmann2021_1}. Comparative performance of these respective approaches is yet to be assessed. 

Also contributing to the cost of ADAPT-VQE, a complete VQE convergence must be conducted between each incremental step. While this is largely tractable for early steps, as the ansatz remains shallow, it could rapidly become prohibitively expensive to implement. Grimsley {\it et al.} \cite{Grimsley2022} nonetheless showed that the build-in "recycling" of parameters (initialization using the optimal values from the previous step) allow for rapid convergence and avoidance of local optima. 
Grimsley \textit{et al.} \cite{Grimsley2019} show that using the ADAPT-VQE method outperforms UCCSD in terms of accuracy for a given number of ansatz parameters (which is a proxy for the number of operators as we need one parameter for each operator). Using $\mathrm{BeH_2}$ as an example, they show that ADAPT-VQE achieves an error of $10^{-3}$ kcal/mol for about 50-60 parameters (and still significantly less than 100 for $10^{-5}$ kcal/mol), while UCCSD requires nearly 300. They also tested against random ordering of the operator pool and showed that the gradient-based ordering described above performs significantly better.

It is difficult however to assess output at a comparable computational cost. While UCCSD only needs to be optimized once (over 300 parameters in $\mathrm{BeH_2}$ example), ADAPT-VQE needs to be optimized many times as the number of operators (or parameters) included (in addition to computation of $\mathcal{O}(N^4)$ gradients at each iteration). Therefore, it is important to assess the comparative cost of ADAPT-VQE in terms of total number of measurements required, in addition to the number of parameters required to achieve a given accuracy.
Large-scale numerical simulations may be required to assert the superiority of adaptive ansatz methods. Ref.~ \cite{Claudino2020} presents a numerical comparison of ADAPT-VQE and a UCCSD based VQE, corroborating the results presented in Ref.~\cite{Grimsley2019}, showing that the former can achieve excellent accuracy (on $\mathrm{H_2}$, $\mathrm{NaH}$, and $\mathrm{KH}$), however with on average significantly more total measurements than the latter. Due to the targeted expressibility of the ansatz produced, ADAPT-VQE has also been shown to be resilient to the barren plateau problem \cite{Grimsley2022} (other numerical evidence can be found in Refs. \cite{Skolik2021, Bilkis2021}). ADAPT-VQE could however suffer from exponential vanishing of pool operator gradients \cite{Grimsley2022}, though further research is needed to characterize and address this potential issue.  

ADAPT-VQE also inherits some advantageous properties of the UCC ans{\"{a}}tze such as the ease of management of particle number and time-reversal symmetries. Similar to UCC, however, it comes at the cost of a very large number of entangling gates required to implement the fermionic excitation operators into an ansatz, in particular when the qubit lattice has low connectivity (as discussed in the UCC section, see Sec. \ref{eq:ucca}). Qubit-ADAPT-VQE \cite{Tang2021} and Qubit Coupled Cluster (QCC) \cite{Ryabinkin2018} methods detailed below are methods to address this shortcoming. An alternative method called Energy Sorting VQE has also been proposed to not only compute the gradient of operator in the pool, but perform a full VQE optimization on each of them to rank them and include them in groups in the ansatz \cite{Fan2021}.
The principle of ADAPT-VQE has also been replicated in applications beyond electronic structure computation, in particular for periodic systems \cite{Liu2020}, and nuclear structure problems \cite{Romero2022}.

\paragraph{ADAPT-VQE for nuclear structure problems:}

While initially designed for electronic structure problems, ADAPT-VQE has been implemented for nuclear structures problems by Romero \textit{et al.} \cite{Romero2022}. The pool of fermionic operators can be replaced by one and two body operators for an $N$-nuclei wavefunction. The one body operators can be defined as $X_i$, $Y_i$, and $Z_i$, scaling as $3N$. For the two body operators, with $j < k$ the pool can be defined as: 
\begin{align} \label{eq:operator_pool_nuclear_adapt}
    &T_{+}^{jk} = \frac{1}{2}(X_jX_k - Y_jY_k), \quad T_{-}^{jk} = \frac{1}{2}(X_jY_k + Y_jX_k)\nonumber \\
    &U_{+}^{jk} = \frac{1}{2}(X_jX_k + Y_jY_k), \quad U_{-}^{jk} = \frac{1}{2}(Y_jX_k - X_jY_k)\nonumber \\
    &V_{+}^{jk} = X_jZ_k, \quad V_{-}^{jk} = Y_jZ_k, \quad V_{0}^{jk} = Z_jZ_k.
\end{align}

This results in $7N(N - 1)/2$ which results in a pool scaling $\mathcal{O}(N^2)$. This method is tested for both the Lipkin-Meshkov-Glick \cite{Lipkin1965} and the nuclear shell model \cite{Caurier2005, Heyde1994}, up to N=12 and demonstrates reasonable scaling in the number of outer-loop iteration required to reach good accuracy.  

\paragraph{qubit-ADAPT-VQE:}

The Qubit-ADAPT-VQE \cite{Tang2021} proposes an incremental selection of operators directly from the Pauli string exponentials produced from a given encoding rather than at the fermionic-operator level. Namely, this implies building an operator pool, with operators structured as 
\begin{equation} \label{eq:operator_pool_qubit_adapt}
    \hat{A}_a = i \bigotimes_i^N \hat{P}_i, \quad \hat{P}_i \in \{I, X, Y, Z\}^{\otimes N}.
\end{equation}
From this point, the ansatz is constructed as presented in Eq.~(\ref{eq:adapt-vqe}).

Further actions can be taken to restrict this operator pool. First restricting operations to those verifying time-reversal symmetry, removing from the pool in Eq.~(\ref{eq:operator_pool_qubit_adapt}) imaginary operators which have no impact on energy if $\hat{H}$ is time-reversal symmetric. The Pauli strings included in the pool are also selected only from those produced from the fermionic excitation mapping (a mapping that must happen anyway to produce the measurable Hamiltonian). Tang et al. \cite{Tang2021} also show analytically that a linear number of operator $(2N - 2)$ is required for the ansatz to be analytically exact and describe a method to select this pool of operators. They also suggest reducing the string Pauli weights by removing the Pauli $Z$ operators used for anti-symmetry of the wave function in the Jordan-Wigner mapping (Sec. \ref{sec:Encoding} and show that this does not impact energy estimate. This implies a maximum Pauli weight of 4 for any Pauli string used to construct the ansatz, allowing for significant depth contraction.

While it is clear that the Pauli weight reduction from removing Pauli-Z chains is not exclusive to this method we conjecture that it works in this instance because qubit-ADAPT-VQE uses one parameter for each Pauli string (instead of one per fermionic operator) and is, therefore, able to variationally learn the anti-commuting relationships required to reach ground-state energy (a view also supported in Ref.~\cite{Yordanov2021}).
Shkolnikov et al. \cite{Shkolnikov2021} also showed that $(2N - 2)$ is the minimum size of a complete pool comprised of Pauli strings. They also show that while minimal complete pools do not perform well on electronic structure Hamiltonian, these can be symmetry-adapted to successfully model ground state energy, achieving outer-loop measurement scaling of $\mathcal{O}(N^5)$.
Overall, this approach allows a significant reduction in the number of CNOT gates ($4$ per operator) required for the implementation of adaptive ansatz albeit at the cost of introducing a larger pool to sample from using the gradient-based selection rules, and as shown in Ref. \cite{Tang2021} more parameters to achieve a given accuracy. In particular, Mukherjee \textit{et al.} \cite{Mukherjee2022} show that qubit-ADAPT-VQE where operators are taken from a pool of Hamiltonian commutators produces a significantly more compact circuit that the HVA and the UCCSD ans{\"{a}}tze.

\paragraph{QEB-ADAPT-VQE:}

The qubit-excitation-based adaptative VQE \cite{Yordanov2021} (QEB-ADAPT-VQE) offers an interesting compromise between ADAPT-VQE and qubit-ADAPT-VQE, by having fewer CNOT gates than both, yet a similar number of parameters than ADAPT-VQE. It is based on a previous ansatz labeled Qubit Coupled Cluster Singles and Doubles (QCCSD) \cite{Xia2020} which uses the same qubit-excitations, up to second order, but without the adaptive aspect. It introduces two main changes:
\begin{itemize}
    \item Screening process includes a new step, whereby the top $k$ candidate operators in the pool (by gradient magnitude) are used for full VQE optimizations, with the one triggering the largest energy drop being selected for incorporation. \item It replaces the pool of operators with qubit-excitation operators \cite{Yordanov2020_QE}. These have been developed as a CNOT efficient alternative to the conventional implementation of fermionic excitation operators.
\end{itemize}

The premise for qubit-excitation operators is simply based on qubit creation and annihilation operators ($Q_i^{\dagger}, Q_i$), similar to the ones used in Jordan-Wigner, but without using the Pauli-Z chains maintaining anti-commutation relations (Ref. \cite{Yordanov2020_QE} shows how to re-incorporate anti-commutation properties, but this is not used in QEB-ADAPT-VQE). Therefore one can define
\begin{align}
    &Q_i^{\dagger} = \sigma_i^- = \frac{1}{2} (X_i - iY_i) \nonumber \\
    &Q_i = \sigma_i^+ = \frac{1}{2} (X_i + iY_i).
\end{align}
To construct operator pools from these, Ref. \cite{Yordanov2020_QE} proceeds by producing skew-Hermitian  operators (to later be exponentiated) of the type
\begin{align}
    &T_i^k= Q_k^{\dagger}Q_i - Q_i^{\dagger}Q_k \nonumber \\
    &T_{ij}^{kl}= Q_k^{\dagger}Q_l^{\dagger}Q_iQ_j - Q_i^{\dagger}Q_j^{\dagger}Q_kQ_l.
\end{align}
From there, we can derive the parametrized single and double qubit excitations:
\begin{align}
    &A_{ik}(\theta_a) = e^{T_i^k(\theta_a)}\nonumber \\
    &A_{ijkl}(\theta_a) = e^{T_{ij}^{kl}(\theta_a)}. \\
\end{align}
Operators from the pool are selected as in ADAPT-VQE, with the gradient computation rule identical to Eq.~(\ref{eq:adapt_vqe_grad}), and with the additional step mentioned above (although it is unclear from Ref.~\cite{Yordanov2021} whether this additional step has a significant impact on performance).
Overall, this method was shown to achieve a lower number of CNOT gates and parameter count than qubit-ADAPT-VQE. It also shows again that the inclusion of Pauli-Z chains into ansatz operators does not matter as long as there is enough variational flexibility for the correct phase to be recovered (which is likely not applicable using fermionic operators in the pool).

\paragraph{Entangler pool compression:} \label{sec:MI_assisted_VQE}

Research has also focused on addressing the wider question of operator pool optimization for adaptative ans{\"{a}}tze. An interesting method that achieves up to nearly two orders of magnitude reduction in the operator pool size is the Mutual Information (MI) assisted Adaptive VQE \cite{Zhang2021_CEP} (it is worth noting that the method described below can be applied to any adaptive ansatz described in this review).
The idea behind this method is to screen operators in the pool based on their mutual information \cite{Amico2008, Huang2005, Rissler2006}. Operators which have a higher correlation of information across the qubits it acts on for an approximate wave function are likely to contribute significantly more to the overall energy estimate. To implement this MI screening, one must first compute an approximation of the ground state wave function using the Density Matrix Renormalization Group (DMRG) method (see Sec. \ref{sec:vqe_vs_conventional}). From the DMRG wave function, the MI of each qubit pair must then be computed as
\begin{equation} \label{eq:mutual_information}
    I_{ij} = \frac{1}{2} \left( S(\rho_i) + S(\rho_j) - S(\rho_{ij} \right)) (1 - \delta_{ij}),
\end{equation}
where $\rho_{x}$ represents the reduced density matrix of system $x$, and $S(\rho)$ represents the von Neumann entropy of $\rho$, $\delta_{ij}$ is the Kronecker delta. The correlation strength for each operator $\tau_a$ in the pool can then be computed as
\begin{equation}
    C(\tau_a) = \frac{1}{q_{\tau_a}(q_{\tau_a} - 1)} \sum_{ij \in Q(\tau_a), i \neq j } I_{ij},
\end{equation}
where $q_{\tau_a}$ is the Pauli weight of the operator (or the number of qubit it acts on), and $Q(\tau_a)$ the set of qubit indices the operator acts on. Operators can then be ranked based on both their gradient (as in other adative methods) and their correlation strength). In Ref.~ \cite{Zhang2021_CEP}, Zhang \textit{et al.} suggest to cut off a certain percentage of operators with low correlation strength which they optimize numerically.

\subsubsection{Iterative Hamiltonian dressing (iterative Qubit Coupled Cluster (iQCC) and extensions)} \label{sec:Hamiltonian_dressing}
The QCC ansatz \cite{Ryabinkin2018} is not strictly speaking an adaptive ansatz in that its structure is not decided throughout the optimization process. However, because pre-processing of the relative importance of each of the operators incorporated in the ansatz is required to make it tractable, we thought it is more appropriate to include it in this section. It also makes it easier to present the iterative QCC, which is indeed an adaptive ansatz that makes use of the concept of Hamiltonian dressing to grow the Hamiltonian instead of the ansatz at each iteration.

\paragraph{The Qubit Coupled Cluster ansatz:} QCC was introduced as a means to bypass the detrimental non-local action arising in the UCC ansatz, and the large number of two-qubit gates that ensue. It is in essence very similar to the qubit-ADAPT-VQE, although with the addition of a Qubit Mean-Field wave function, and initially presented in Ref.~\cite{Ryabinkin2018} without adaptive looping and without prior selection of a restricted pool of Pauli strings.

The central premise of QCC is that, unlike UCC, it uses spin operators directly to construct the ansatz instead of fermionic excitation operators which are then transformed. The first step to construct this ansatz is to separate the wave function into mean field and correlated components, such that
\begin{equation}
    \ket{\psi(\boldsymbol{\tau}, \boldsymbol{\Omega})} = U(\boldsymbol{\tau}) \ket{\boldsymbol{\Omega}}.
\end{equation}
The mean field component $\ket{\boldsymbol{\Omega}}$ can be simply prepared through single qubit rotations on each individual qubit in the wave function.
\begin{align}
    &\ket{\boldsymbol{\Omega}} = \bigotimes_j^N \ket{\Omega}_j \nonumber \\
    & \ket{\Omega}_j = R(\theta_j, \phi_j) \ket{0}_j \nonumber \\
    &\ket{\Omega}_j =  \cos\frac{\theta_j}{2} \ket{0})j + e^{i\phi_j}\sin\frac{\theta_j}{2} \ket{1}_j,
\end{align}
with $\theta$, $\phi$ parameters for the rotation of each qubit. The correlation component consist in an entangling block unitary, built from amplitude parameters $\boldsymbol{\tau} = \{ \tau_a \}$, and a set of corresponding Pauli strings $\{ P_a\}$, as
\begin{align} \label{eq:qcc_generators}
    U(\boldsymbol{\tau}) = \prod_a^{\boldsymbol{P}}  e^{-i\tau_a \hat{P_a}/2},
\end{align}
with $\boldsymbol{P}$ the total number of Pauli strings used. With this we can define the VQE problem using the QCC ansatz:
\begin{align} \label{eq:cost_qcc}
    E_{QCC} = \min_{\boldsymbol{\tau}, \boldsymbol{\Omega}} \bra{\boldsymbol{\Omega}} U^{\dagger}(\boldsymbol{\tau}) \hat{H} U(\boldsymbol{\tau}) \ket{\boldsymbol{\Omega}}.
\end{align}

Because the number of possible Pauli strings candidates for this ansatz scales $\mathcal{O}(4^N)$, it is necessary to carefully select the appropriate operators to incorporate into the entangling block. A first proposal in Ref.~\cite{Ryabinkin2018} is to look at the (negative) contribution of using each operator individually once its amplitude parameter ($\tau_a$) is optimized. This rapidly becomes computationally prohibitive, and as such Ryanbinkin et al. \cite{Ryabinkin2018} also propose to rank operator contributions based on their first and second order gradients. In a manner that is similar to that presented in ADAPT-VQE, the first order derivative with respect to the amplitude parameter $\tau_a$ at $\tau_a = 0$ is given by
\begin{equation} \label{eq:qcc_grad}
    \frac{\partial E(\tau_a, \hat{P_a})}{\partial \tau_a} = \bra{\boldsymbol{\Omega}^*} \left(- \frac{i}{2}[ \hat{H}, \hat{P}_a] \right) \ket{\boldsymbol{\Omega}^*}
\end{equation}
where $\ket{\boldsymbol{\Omega}^*}$ is the optimized mean-field qubit wave function with respect to $\boldsymbol{\theta}$ and $\boldsymbol{\phi}$. This remains exponential in scaling, and further restrictions on the Pauli strings to be included in the pool must be implemented.
In particular, Ref.~\cite{Ryabinkin2020} introduces the concept of direct interaction set (DIS), which aims at excluding from the operator pool all those with zero gradients, and grouping the remaining $\mathcal{O}(4^N)$ operators into groups having identical gradients up to a sign. This results in a polynomial scaling number of groups ($\mathcal{O}(N^4)$) each composed of $2^{N-1}$ operators.

\paragraph{iQCC:} \label{sec:iqcc}

The iterative Qubit Coupled Cluster method \cite{Ryabinkin2020} is an improvement on the QCC method which aims to reduce the number of operators that can be included in the ansatz by incorporating operators into the Hamiltonian iteratively instead of increasing the ansatz as it is done for ADAPT-VQE and extensions. It works based on a slightly modified cost function, compared to Eq.~(\ref{eq:cost_qcc}):
\begin{align} \label{eq:cost_iqcc}
    E_{iQCC} = \min_{\boldsymbol{\tau}} \{ \min_{\boldsymbol{\Omega}} \bra{\boldsymbol{\Omega}}  \hat{H}_d(\boldsymbol{\tau})  \ket{\boldsymbol{\Omega}} \},
\end{align}
where $\hat{H}_d = U(\boldsymbol{\tau})^{\dagger} \hat{H}U(\boldsymbol{\tau})$ is called the \textit{dressed Hamiltonian}. The dressed Hamiltonian can be computed recursively, starting from $\hat{H}_d^{(0)} = \hat{H}$, and each $\hat{H}_d^{(k)}$ being dependent on the first $k$ amplitude in the vector $\boldsymbol{\tau}$, such that $\hat{H}_d^{(k)} =  \hat{H}_d^{(k)}(\boldsymbol{\tau}_{1 \rightarrow k})$:

\begin{align} \label{eq:dressed_hamiltonian}
    \hat{H}_d^{(k)} &= e^{i\tau_k \hat{P}_k / 2} \hat{H}_d^{(k-1)} e^{-i\tau_k \hat{P}_k / 2} \nonumber \\
    & = \hat{H}_d^{(k-1)} - \frac{i \sin{\tau_k}}{2} \left[\hat{H}_d^{(k-1)}, \hat{P}_k \right] \nonumber \\
    & + \frac{(1 - \cos{\tau_k})}{2} \hat{P}_k \left[\hat{H}_d^{(k-1)}, \hat{P}_k \right],
\end{align}
where the exponential terms $e^{i\tau_k \hat{P}_k / 2}$ are called the generators of the iQCC process, and akin to the elements of the QCC ansatz presented in Eq.~(\ref{eq:qcc_generators}). The process for completing the iQCC optimization process works as follows:
\begin{itemize}
    \item Inputs are the mean-field parameters of $\ket{\boldsymbol{\Omega}}$ optimized at the previous iteration, and the dressed Hamiltonian of the previous iteration  $\hat{H}_d^{(k-1)}$ (or $\hat{H}_d^{(0)}$ at the start).
    \item Using the optimized qubit mean-field wave function, and $\hat{H}_d^{(k-1)}$, use a screening procedure to select a number of generators $g$ with the largest gradient from an operator pool. The value for $g$ is at the discretion of the user (including $g=1$, although Ryabinkin et al. \cite{Ryabinkin2020} point out that increasing $g$ accelerates convergence).
    \item Using the selected generators, construct the appropriate ansatz and proceed to a VQE optimization on QPU of both the mean-field parameters and $g$ generator amplitudes $\tau$. Ryabinkin et al. \cite{Ryabinkin2020} suggest using random initializations for the amplitudes or set $\boldsymbol{\tau}= 0$, if random initialization does not start from a lower energy than at the previous iteration.
    \item Once parameters are optimized, incorporate the $g$ generators into the Hamiltonian by computing $\hat{H}_d^{(k)}$ using Eq.~(\ref{eq:dressed_hamiltonian}), and begin a new iteration unless convergence is reached.
\end{itemize}

Using this method, one can enforce a fixed size for the ansatz, at each iteration, determined uniquely by the constant $g$. This provides many advantages from a NISQ perspective as it allows to directly adjust the size of the ansatz in each iteration to the noise level acceptable (and which can be mitigated) for the device being used.
This comes however with two significant caveats. First, there is no guarantee that the method can converge to the exact solution, despite successfully demonstrating the method works for small systems \cite{Ryabinkin2020}. Secondly, the number of terms in the Hamiltonian grows in a somewhat prohibitive manner. It is estimated that the Hamiltonian grows by a factor of $\sim (3/2)^{g}$ at each iteration, which means that for a number of iterations $k$, and with $\mathcal{P}$ the number of terms in $\hat{H}_d^{(0)}$, the Hamiltonian scales $\mathcal{O}(\boldsymbol{P}(3/2)^{g k})$, or exponentially in the number of iterations (with an obvious upper bound of $\mathcal{O}(4^N)$).
This was improved upon in Ref.~\cite{Lang2020}, where Lang et al. show that using Truncation of the  Baker-Campbell-Hausdorff expansion, one can restrict the increase in the number of terms by a factor $\mathcal{O}(g^2)$ at each iteration, and hence an overall scaling of  $\mathcal{O}(g^{2k})$. They show, using an active space of $4$ electrons on $4$ molecular orbitals for $\mathrm{H_2O}$, with $k=1$, one can recover most of the electron correlation energy. Reaching chemical accuracy requires between $k=5$ and $k=10$ depending on the bond distance. That considered, numerical analysis of the growth in the number of terms in the Hamiltonian when using iQCC shows a plateau after a number of iterations, owing to the fact that many terms will have negligible weights, resulting in a low polynomial scaling \cite{Genin2022}. Finally, in Ref. \cite{Ryabinkin2021}, Ryabinkin et al. propose to use ex-post corrections on the energy obtained from iQCC based on perturbation theory, to reduce the number of iteration $k$ required for the implementation of the method.

Overall, despite the promising fixed-length ansatz, the viability of the method depends on further research regarding scalability and extension of the method to very large systems.The analysis presented by Genin {\it et al.}  \cite{Genin2022} suggests that that iQCC could compete with methods such as DFT in terms of scaling and accuracy using a minimum of 72 fully-connected and corrected qubits. 

\paragraph{ClusterVQE:} In Ref.~\cite{Zhang2021}, Zhang et al. present a method that borrows ideas from ADAPT-VQE, iQCC and Mutual Information (MI) assisted Adaptive VQE to optimize the use of quantum resources. The first step in this method is to create a cluster of qubits (across the qubit register of the QPU used) that have strong MI within, and low MI across, each cluster. MI was shown to be a strong metric to measure the correlation between these quantum clusters \cite{Rissler2006}, computed as presented in Eq.~(\ref{eq:mutual_information}). As described in Sec. \ref{sec:MI_assisted_VQE}, the MI can be initially approximated using a DMRG approximation of the ground state wave function. Once the MI for each qubit pair has been computed, a conventional clustering algorithm can be used to create a set of clusters that minimizes the MI between clusters (sum over MIs between inter-cluster qubits).

The idea behind ClusterVQE is to separate the pool of operators (akin to those found in other adaptive methods) into entanglers that act within a cluster of qubits (noted $U_{c_i}$, $i$ labeling a specific cluster) and those acting on two different clusters, coupling them (noted $U_{c_i, c_j}$). The former are used to grow the ansatz, similarly to qubit-ADAPT-VQE (see Sec. \ref{sec:adapt-vqe}), the latter are used to dress the Hamiltonian similarly to iQCC (see Sec. \ref{sec:iqcc}). The ClusterVQE optimization problem can then be written as
\begin{equation}
    E = \min_{\boldsymbol{\theta, \phi}}\bra{\psi_{HF}} \prod_i U_{c_i}^{\dagger}(\theta_i) \hat{H}^d(\boldsymbol{\phi}) \prod_i U_{c_i}(\theta_i) \ket{\psi_{HF}},
\end{equation}
with, the dressed Hamiltonian
\begin{equation}
    \hat{H}^d(\boldsymbol{\phi}) = \prod_{i\neq j}U_{c_{ij}}^{\dagger}(\phi_{ij}) \hat{H} \prod_{i\neq j}U_{c_{ij}}(\phi_{ij}).
\end{equation}

The optimization process works similar to the methods mentioned above, where a pool of entanglers is first created (Zhang et al. \cite{Zhang2021} recommend selecting qubit-operators from the pool generated by single and double fermionic excitations) and ranked based on their gradients, computed as in Eq.~(\ref{eq:adapt_vqe_grad}). Entanglers that couple qubit clusters are used to dress the Hamiltonian, others are used to grow the ansatz to be implemented on the quantum computer. Once top entanglers have been selected and integrated, a VQE optimization is conducted. The wave function obtained is then used to update the MI (which can be computed from the one and two-body reduced density matrices) and a new loop begins.

A first observation to make on the ClusterVQE is that it allows separating the ansatz into smaller, shallower depth quantum circuits corresponding to each qubit cluster \cite{Zhang2021}. The quantum circuit for each cluster can be optimized separately as their gradients are independent of the rest of the ansatz, allowing for implementation of ClusterVQE on smaller quantum computers. It is worth noting however that doing so means that the number of measurements required must be multiplied by the number of qubit-clusters, though these can be parallelized. It also means that the number of terms in the Hamiltonian is lower than the iQCC method as only certain entanglers are integrated into the dressed Hamiltonian.

Finally, Zhang et al. \cite{Zhang2021} show numerically that ClusterVQE can achieve similar accuracy as iQCC but with significantly lower numbers of Hamiltonian terms. The shallower circuits also offer some noise resilience compared to VQE and qubit-ADAPT-VQE, though iQCC remains the most resilient due to its fixed ansatz depth.
A few caveats are worth mentioning, however. Despite promising features, the dressed Hamiltonian still grows exponentially in the number of cross-qubit-cluster entanglers; while these have been shown to be few for small systems (e.g. $\mathrm{LiH}$ in Ref. \cite{Zhang2021}) there is at this stage no way to tell how this method scales on large, highly entangled systems. Also noted by Zhang et al., a potential bottleneck for the method is the inter-MI clustering process which could become too costly to compute accurately enough.

\subsubsection{Ansatz structure optimization} \label{sec:gate_structure_optimization}

Several methods have been developed to iteratively update the structure of the ansatz throughout the optimization process. Unlike the adaptive ans\"atze presented in the previous section, these methods do not propose to build the circuit layer by layer but start from an initial guess of the ansatz structure to progressively learn an optimal one. We outline a few of these methods at a high level below. 

\paragraph{RotoSelect \cite{ostaszewskiStructureOptimizationParameterized2021}:} this method is built as an extension to the RotoSolve optimizer \cite{Nakaji2021, ostaszewskiStructureOptimizationParameterized2021}, which we present in more details in Sec.~\ref{sec:analytical_opt}. Rotosolve uses the fact that the expectation value of the Hamiltonian is a $2\pi$ periodic sine-type function of a given parameter to find the optimal value. This can be done by sampling three different values of the parameter and finding the minimum using trigonometric relationships. RotoSelect extends that idea, by optimizing not only the parameter but also the Hilbert space dimension of the rotation gate. In other words, the algorithm finds which orientation, $X, Y$, or $Z$, allows for the largest reduction in energy for a given rotation gate and replaces the orientation of the gate accordingly. This is associated with an additional sampling cost on the initial iterations of the VQE, but has been shown in Ref.~\cite{ostaszewskiStructureOptimizationParameterized2021} to significant improve convergence rate over RotoSolve and other gradient-based optimizers. These results were tested on HEA, and could be different on the likes of UCC-based ans\"atze.     

\paragraph{Variable Ansatz (VAns) \cite{Bilkis2021}:} The VAns is another algorithm that proposes adapting the structure of the ansatz as the optimization proceeds. Unlike RotoSelect, mentioned above, it not only changes the axes of rotation gates but also incorporates and removes gates throughout the process. The first step in this method is to define a dictionary of parametrized gates. From an initial circuit configuration (which can be flexibly designed), pre-defined insertion rules stochastically select gates from the dictionary to add them to the circuit. Additional simplification rules are used to identify gates with lower impact on the resulting energy and remove them from the ansatz. The ansatz is primarily designed for use on Quantum Machine Learning tasks which cannot benefit from a problem tailored ansatz (as it is the case for VQE), but is also shown to outperform HEA on the Ising and Heisenberg models, and on $\mathrm{H_2}$ and $\mathrm{H_4}$ \cite{Bilkis2021}. The key advantage of this approach is the large flexibility it provides in terms of designing rules, allowing for efficient design and tailoring to any learning task, while offering some degree of resilience to the barren plateau problem. The cost of implementing the method is unclear however, and while it reduces the burden on quantum resources, it could result in a large pre-factor cost for its implementation, requiring further research. 

\paragraph{Machine learning of ansatz structure and Quantum Architecture Search (QAS):} These comprise a series of methods aiming at learning an optimal ansatz structure using machine learning tools. While it would probably deserve a review in its own right, we outline here some key publications regarding this family of approaches. The Evolutionary VQE (EVQE) \cite{Rattew2019} uses evolutionary programming to dynamically generate and optimize the ansatz and is shown to produce ansatz which are nearly twenty times shallower (with twelve times fewer CNOT gates) than UCCSD. Rattew et al. \cite{Rattew2019} also show numerically a significant ability of the EVQE to learn and thereby reduce the impact of inherent quantum noise, all while providing resilience to the barren plateau problem. Similarly, the Multi-objective Genetic VQE (MoG-VQE) \cite{Chivilikhin2020} uses a genetic algorithm to learn the circuit topology of a series of blocks constituting the ansatz. This results in blocks of gates resembling the HEA structure, but only spanning a limited number of qubits. The method achieves a significant reduction in two-qubit gates compared to HEA (showing that one can reach chemical accuracy on a 12-qubit version of $\mathrm{LiH}$ with only 12 CNOTs \cite{Chivilikhin2020}). 

QAS was initially developed in Ref.~\cite{Du2020} as a means to improve both trainability and noise resilience of variational quantum algorithms. Similar to the methods described above, QAS modifies the optimization problem by incorporating the structure of the quantum circuit in the cost function. In Ref.~\cite{Zhang2020_QAS}, Zhang et al. extend this idea by creating the Differentiable QAS (DQAS), which is based on the differentiable neural architecture search (DARTS) \cite{Liu2018}. The idea is to relax the discrete search space of network architectures onto a continuous and differentiable domain, accelerating QAS \cite{Zhang2020_QAS}. Additional work on QAS includes a version based on Neural Predictors \cite{Zhang2021_QAS}, on Deep Reinforcement Learning \cite{Kuo2021}, and on meta-learning \cite{Chen2021_QAS}. QAS can also be used to improve noise resilience of an ans\"atze \cite{Wang2021_QAS}.
Overall, while very promising, machine learning based ansatz all suffer from a common pitfall: the cost of training machine learning models to optimize ansatz for large-scale systems remains largely untested. Studying the training cost and cost scaling for these methods would be an interesting research avenue to warrant their applicability on larger systems than has been analyzed so far. 

\subsection{Discussion on ans\"atz used in the VQE context} \label{sec:ansatz_discussion}

There has been a very large amount of research published on VQE ans{\"{a}}tze over recent years, we summarize in this subsection the key findings from our research. The k-UpCCGSD ansatz \cite{Lee2019} (and extensions) have been numerically shown to achieve excellent accuracy while offering linear scaling, thereby arguably offering the best trade-off in cost to accuracy among ans\"atze proposed at the time of writing. Adaptive ans{\"{a}}tze could place themselves as a reliable alternative subject to further studies on their expected computational cost.
Layered HEA are likely not suitable for large systems. As they are not physically motivated, they require a large number of parameters and need to span a significant proportion of the Hilbert space to guarantee a good ground state approximation can be reached. This also makes HEA particularly prone to barren plateaus \cite{Holmes2021}. There are good arguments however to suggest that VQE may be resilient to barren plateaus if the right design choices are made in the ansatz (except for Noise-Induced Barren Plateau \cite{Wang2020}). In particular, these are; local encodings for the Hamiltonian \cite{Cerezo2021_BP, Uvarov2020}, an ansatz that is problem tailored (e.g. UCC), or is constructed adaptively during the optimization (e.g. ADAPT-VQE \cite{Grimsley2019} and others), using specific initialization techniques (e.g. Ref.~\cite{Grant2019, Patti2021}, and use of a local mapping for the Hamiltonian (e.g. Bravyi-Kitaev).

Qubit-based ans{\"{a}}tze \cite{Ryabinkin2018, Ryabinkin2020, Lang2020} (or qubit-excitations based ans{\"{a}}tze) could be more appropriate for the NISQ era than fermion based (or hardware efficient) ans{\"{a}}tze. That is because they offer the option to parametrize the ansatz with respect to each Pauli string used in the construction. Given enough variational flexibility, this allows forgoing Pauli-Z chains used for maintaining the antisymmetric relationship of fermionic operators under the Jordan-Wigner mapping. As such, each operator is acting on very few qubits (up to four in the Jordan-Wigner mapping, instead of $\mathcal{O}(N)$ when using a fermionic ansatz), reducing the reliance on costly two-qubit gates and allowing depth reduction. These however tend to require a larger number of parameters and operators, and as such may be more cumbersome to optimize and have slightly worse computational scaling.

Adaptive ans{\"{a}}tze have been a significant focus of recent research. While they have brought several critical breakthroughs, the scaling of the number of measurements required remains unclear. We find that the main advantages of adaptive ans{\"{a}}tze are the reduction in number of parameters (though as far as we have seen, less than an order of magnitude), and numerically demonstrated resilience to barren plateau. This however comes at a significant computational cost of gradient estimations (scaling with the size of the Hamiltonian) and repeated VQE optimizations (shallow at the beginning of the process, but not at the end). The relative benefit of adaptive ansatz should be studied in more detail.

Some research has been conducted on the impact of initialization on the performance of different ans\"tze, in particular, Choquette \textit{et al.} \cite{Choquette2021} numerically show that a computational basis initialization for HEA has a minor impact on target state fidelity compared to Hartree-Fock initialization. Of course, UCC-based ans\"atze are motivated as an evolution of a reference state, and, in general, apply to a qubit register initialized as the Hartree Fock wavefunction \cite{Peruzzo2014}. As a side note, Murta and Fern\'andez-Rossier \cite{Murta2021} propose a quantum routine to model the Gutzwiller wavefunction \cite{Gutzwiller1963} on a quantum device. This wavefunction is a physically-motivated model which can be applied to a variety of lattice systems \cite{Hubbard1963}. While not providing a full parametrized ansatz, it was shown to provide a better approximation than a mean-field method for the ground state of the Fermi-Hubbard model, and could therefore be used as an initialization strategy for lattice model VQE implementations \cite{Murta2021}. Further research on the preparation of the Gutzwiller wavefunction is presented in Ref. \cite{Seki2022}.





