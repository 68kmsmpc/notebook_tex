\begin{MintedVerbatim}[commandchars=\\\{\}]
\PYG{k}{def}\PYG{+w}{ }\PYG{n+nf}{sparse\PYGZus{}to\PYGZus{}graph}\PYG{p}{(}\PYG{n}{A}\PYG{p}{)}\PYG{p}{:}
\PYG{+w}{    }\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}
\PYG{l+s+sd}{    희소행렬 A \PYGZhy{}\PYGZgt{} NetworkX Graph/DiGraph 변환}

\PYG{l+s+sd}{    Returns}
\PYG{l+s+sd}{    \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}}
\PYG{l+s+sd}{    G : nx.Graph}
\PYG{l+s+sd}{    \PYGZdq{}\PYGZdq{}\PYGZdq{}}

    \PYG{k}{if} \PYG{o+ow}{not} \PYG{n}{issparse}\PYG{p}{(}\PYG{n}{A}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{raise} \PYG{n+ne}{ValueError}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{A must be a scipy.sparse matrix}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}

    \PYG{c+c1}{\PYGZsh{} COO로 변환}
    \PYG{n}{A} \PYG{o}{=} \PYG{n}{A}\PYG{o}{.}\PYG{n}{tocoo}\PYG{p}{(}\PYG{n}{copy}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{)}
    \PYG{c+c1}{\PYGZsh{}COO 에서는 값을 아래와같이 3개의 어레이로 저장}
    \PYG{c+c1}{\PYGZsh{}data : [3,4,2,7]}
    \PYG{c+c1}{\PYGZsh{}row : [0,0,1,3]}
    \PYG{c+c1}{\PYGZsh{}col : [2,4,1,3]}
    \PYG{c+c1}{\PYGZsh{}그리고 같은 인덱스 순서대로 0행 2열에는 3이라는 값이 있고 마찬가지로 총 4개의 원소가 있는 행렬을 표현한다.}

    \PYG{n}{G} \PYG{o}{=} \PYG{n}{nx}\PYG{o}{.}\PYG{n}{Graph}\PYG{p}{(}\PYG{p}{)}
    \PYG{c+c1}{\PYGZsh{} NetworkX 패키지의 Graph 클래스를 불러온다.}
    \PYG{n}{G}\PYG{o}{.}\PYG{n}{add\PYGZus{}nodes\PYGZus{}from}\PYG{p}{(}\PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{A}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} 노드: 0..n\PYGZhy{}1}
    \PYG{c+c1}{\PYGZsh{} A(coo matrix) 의 길이, 즉 행렬의 원소의 개수만큼의 node를 만든다.}
    \PYG{n}{vals} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{abs}\PYG{p}{(}\PYG{n}{A}\PYG{o}{.}\PYG{n}{data}\PYG{p}{)}
    \PYG{c+c1}{\PYGZsh{} 행렬의 데이터 (이경우 h\PYGZus{}ij) 를 하나의 어레이로 만든다.}

    \PYG{c+c1}{\PYGZsh{} 동일 엣지 중복 합치기(무향일 때 i\PYGZlt{}j 묶기)}
    \PYG{k+kn}{from}\PYG{+w}{ }\PYG{n+nn}{collections}\PYG{+w}{ }\PYG{k+kn}{import} \PYG{n}{defaultdict}
    \PYG{n}{edges} \PYG{o}{=} \PYG{n}{defaultdict}\PYG{p}{(}\PYG{n+nb}{float}\PYG{p}{)}
    \PYG{c+c1}{\PYGZsh{} 딕셔너리를 만들때, 특정 키가 주어졌을때, 그 키가 만약 존재하지 않다면 0.0 이라는 값을 그 키로 하는 value 를 만든다.}
    \PYG{k}{for} \PYG{n}{i}\PYG{p}{,} \PYG{n}{j}\PYG{p}{,} \PYG{n}{v} \PYG{o+ow}{in} \PYG{n+nb}{zip}\PYG{p}{(}\PYG{n}{A}\PYG{o}{.}\PYG{n}{row}\PYG{p}{,} \PYG{n}{A}\PYG{o}{.}\PYG{n}{col}\PYG{p}{,} \PYG{n}{vals}\PYG{p}{)}\PYG{p}{:}
    \PYG{c+c1}{\PYGZsh{} 행(i), 열(j), 행렬원소(h\PYGZus{}ij)}
        \PYG{k}{if} \PYG{n}{i} \PYG{o}{==} \PYG{n}{j} \PYG{p}{:}
            \PYG{k}{continue}
            \PYG{c+c1}{\PYGZsh{} 대각원소는 자기와의 간선이므로, 이는 고려하지 않는다.}
        \PYG{n}{key} \PYG{o}{=} \PYG{p}{(}\PYG{n+nb}{min}\PYG{p}{(}\PYG{n}{i}\PYG{p}{,} \PYG{n}{j}\PYG{p}{)}\PYG{p}{,} \PYG{n+nb}{max}\PYG{p}{(}\PYG{n}{i}\PYG{p}{,} \PYG{n}{j}\PYG{p}{)}\PYG{p}{)}
        \PYG{c+c1}{\PYGZsh{} key를 만들어 이를 이용해 간선(edges) 를 만들것이다.}
        \PYG{c+c1}{\PYGZsh{} 그런데, \PYGZsq{}\PYGZsq{}무향\PYGZsq{}\PYGZsq{} 그래프 에선 두 노드 사이의 방향이 없으므로}
        \PYG{c+c1}{\PYGZsh{} h\PYGZus{}ij 와 h\PYGZus{}ji 를 같은 키로 만들어 위와같이 정의한다.}
        \PYG{n}{edges}\PYG{p}{[}\PYG{n}{key}\PYG{p}{]} \PYG{o}{+}\PYG{o}{=} \PYG{l+m+mf}{0.5}\PYG{o}{*}\PYG{n+nb}{float}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}
        \PYG{c+c1}{\PYGZsh{} 누적(합)}
        \PYG{c+c1}{\PYGZsh{} key를 정의할때 (min(i, j), max(i, j))와 같이 했으므로}
        \PYG{c+c1}{\PYGZsh{} h\PYGZus{}ij 와 h\PYGZus{}ji 는 같은 key에 대응되고, 이 두 값은 하나의 edge 에 대응되어야한다.}
        \PYG{c+c1}{\PYGZsh{} 우리가 다루는 행렬에서는 이 두 값이 같으므로, 두값을 평균을 내어 처리한다.}

        \PYG{k}{for} \PYG{p}{(}\PYG{n}{i}\PYG{p}{,} \PYG{n}{j}\PYG{p}{)}\PYG{p}{,} \PYG{n}{w} \PYG{o+ow}{in} \PYG{n}{edges}\PYG{o}{.}\PYG{n}{items}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
        \PYG{c+c1}{\PYGZsh{} 저장된 딕셔너리에서 키인 (i,j) 와 그때의 행렬원소 (h\PYGZus{}ij)를 for문으로 가져온다.}
            \PYG{n}{G}\PYG{o}{.}\PYG{n}{add\PYGZus{}edge}\PYG{p}{(}\PYG{n}{i}\PYG{p}{,} \PYG{n}{j}\PYG{p}{,} \PYG{n}{weight}\PYG{o}{=}\PYG{n}{w}\PYG{p}{)}
            \PYG{c+c1}{\PYGZsh{} 그래프에 i번째 노드와 j번째 노드의 간선으로써 행렬원소 (h\PYGZus{}ij)를 부여한다.}

    \PYG{k}{return} \PYG{n}{G} \PYG{c+c1}{\PYGZsh{} NetworkX 패키지의 Graph 클래스에 노드와 간선들이 저장되어있는 객체}
\end{MintedVerbatim}
