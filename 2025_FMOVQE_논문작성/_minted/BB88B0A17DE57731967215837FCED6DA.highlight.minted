\begin{MintedVerbatim}[commandchars=\\\{\}]
\PYG{k}{def}\PYG{+w}{ }\PYG{n+nf}{least\PYGZus{}Energy}\PYG{p}{(}\PYG{n}{as\PYGZus{}problem}\PYG{p}{)}\PYG{p}{:}
    \PYG{c+c1}{\PYGZsh{} as\PYGZus{}problem :ActiveSpaceTransformer를 통해 힐버트 공간을 줄인 Dirver}
    \PYG{n}{as\PYGZus{}num\PYGZus{}particles} \PYG{o}{=} \PYG{n}{as\PYGZus{}problem}\PYG{o}{.}\PYG{n}{num\PYGZus{}particles}
    \PYG{c+c1}{\PYGZsh{} (up\PYGZhy{}spin 전자수, down\PYGZhy{}spin 전자수) 인 튜플}
    \PYG{n}{as\PYGZus{}num\PYGZus{}spatial\PYGZus{}orbitals} \PYG{o}{=} \PYG{n}{as\PYGZus{}problem}\PYG{o}{.}\PYG{n}{num\PYGZus{}spatial\PYGZus{}orbitals}
    \PYG{c+c1}{\PYGZsh{} 시스템의 spatial orbital 갯수}
    \PYG{n}{as\PYGZus{}fermionic\PYGZus{}hamiltonian} \PYG{o}{=} \PYG{n}{as\PYGZus{}problem}\PYG{o}{.}\PYG{n}{hamiltonian}
    \PYG{c+c1}{\PYGZsh{} 시스템의 헤밀토니안 (여러가지의 형태로 헤밀토니안이 정의되어있음)}
    \PYG{n}{as\PYGZus{}second\PYGZus{}q\PYGZus{}op} \PYG{o}{=} \PYG{n}{as\PYGZus{}fermionic\PYGZus{}hamiltonian}\PYG{o}{.}\PYG{n}{second\PYGZus{}q\PYGZus{}op}\PYG{p}{(}\PYG{p}{)}
    \PYG{c+c1}{\PYGZsh{} 그중 생성/소멸 연산자로 정의된 헤밀토니안}
    \PYG{n}{energy\PYGZus{}arr} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
    \PYG{c+c1}{\PYGZsh{} 각 Ansatz, optimizer 별 최종 수렴 에너지를 저장할 리스트}
    \PYG{n}{ansatz\PYGZus{}order} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
    \PYG{c+c1}{\PYGZsh{} 그래프의 제목을 위해 for 문에서 사용한 Ansatz 순서를 기록하기 위한 리스트}
    \PYG{n}{opt\PYGZus{}order}\PYG{o}{=}\PYG{p}{[}\PYG{p}{]}
    \PYG{c+c1}{\PYGZsh{} 그래프의 제목을 위해 for 문에서 사용한 optimizer 순서를 기록하기 위한 리스트}
    \PYG{n}{qubit\PYGZus{}op}\PYG{p}{,} \PYG{n}{mapper} \PYG{o}{=} \PYG{n}{fermion\PYGZus{}to\PYGZus{}qubit}\PYG{p}{(}\PYG{n}{as\PYGZus{}problem}\PYG{p}{,} \PYG{n}{as\PYGZus{}second\PYGZus{}q\PYGZus{}op}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Pa}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
    \PYG{c+c1}{\PYGZsh{} 사전에 정의한 함수 \PYGZdq{}fermion\PYGZus{}to\PYGZus{}qubit\PYGZdq{}을 통해 생성/소멸 연산자로 정의된 헤밀토니안인 as\PYGZus{}second\PYGZus{}q\PYGZus{}op 를 파울리 스트링으로 매핑}
    \PYG{n}{as\PYGZus{}init\PYGZus{}state} \PYG{o}{=} \PYG{n}{HartreeFock}\PYG{p}{(}\PYG{n}{as\PYGZus{}num\PYGZus{}spatial\PYGZus{}orbitals}\PYG{p}{,}\PYG{n}{as\PYGZus{}num\PYGZus{}particles}\PYG{p}{,}\PYG{n}{mapper}\PYG{p}{)}
    \PYG{c+c1}{\PYGZsh{} 파동함수를 나타내기 위한 초기상태, 특히 UCCSD 에서는 1차여기와 2차여기 연산자들이 가해질 Reference State가 되는 초기상태를 정의. 여기서는 HartreeFock 함수를 통해 생성.}
    \PYG{c+c1}{\PYGZsh{} HartreeFock 상태에서는 Qiskit에서 오비탈을 정렬하는 정의에 의해, (up\PYGZhy{}spin 전자수, down\PYGZhy{}spin 전자수) 만큼 앞의 오비탈이 1인 상태}
    \PYG{n}{uccsd} \PYG{o}{=} \PYG{n}{UCCSD}\PYG{p}{(}\PYG{n}{as\PYGZus{}num\PYGZus{}spatial\PYGZus{}orbitals}\PYG{p}{,}\PYG{n}{as\PYGZus{}num\PYGZus{}particles}\PYG{p}{,}\PYG{n}{mapper}\PYG{p}{,}\PYG{n}{initial\PYGZus{}state}\PYG{o}{=}\PYG{n}{as\PYGZus{}init\PYGZus{}state}\PYG{p}{,} \PYG{n}{generalized}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{)}
    \PYG{c+c1}{\PYGZsh{} UCCSD Ansatz 를 Qiskit 에서 제공하는 패키지를 이용해 정의.}
    \PYG{c+c1}{\PYGZsh{} generalized 옵션은 임의의 오비탈에서의 전이를 허용하여 계산량은 늘어나지만, 높은 표현력을 얻을 수 있음}
    \PYG{n}{twolocal} \PYG{o}{=} \PYG{n}{TwoLocal}\PYG{p}{(}\PYG{n}{as\PYGZus{}num\PYGZus{}spatial\PYGZus{}orbitals}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ry}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{rz}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{cz}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{initial\PYGZus{}state}\PYG{o}{=}\PYG{n}{as\PYGZus{}init\PYGZus{}state}\PYG{p}{)}
    \PYG{c+c1}{\PYGZsh{} twolocal Ansatz 를 Qiskit 에서 제공하는 패키지를 이용해 정의.}
    \PYG{c+c1}{\PYGZsh{} spin orbital 만큼의 큐비트가 필요하므로, 공간오비탈의 개수에 2배를 해준다.}
    \PYG{c+c1}{\PYGZsh{} Rotation Gate는 \PYGZsq{}ry\PYGZsq{}, \PYGZsq{}rz\PYGZsq{} 를 사용.}
    \PYG{c+c1}{\PYGZsh{} Entanglement는 \PYGZsq{}cz\PYGZsq{} 를 이용해 표현}
    \PYG{n}{ansatzs}\PYG{o}{=}\PYG{p}{[}\PYG{n}{uccsd}\PYG{p}{,}\PYG{n}{twolocal}\PYG{p}{]}
    \PYG{c+c1}{\PYGZsh{} 여러 Ansatz 와 optimizer 에 대해서 실험을 하기위해 각 구성에 대한 리스트를 구성}
    \PYG{n+nb}{iter} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{250}\PYG{p}{,}\PYG{l+m+mi}{1000}\PYG{p}{]}
    \PYG{c+c1}{\PYGZsh{} Ansatz 별로 각 Iteration에서 소요되는 시간이 다르므로 두개의 max\PYGZus{}iter를 정의}
    \PYG{n}{ansatzs\PYGZus{}name}\PYG{o}{=}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{UCCSD}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Two local}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
    \PYG{c+c1}{\PYGZsh{} 이때 Ansatz 는 해당 양자회로를 리스트로 만들었으므로, 그림을 그리는데에 필요한 이름 리스트 또한 만들어준다.}
    \PYG{n}{opt\PYGZus{}names} \PYG{o}{=} \PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{COBYLA}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{SPSA}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{L\PYGZhy{}BFGS\PYGZhy{}B}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
    \PYG{c+c1}{\PYGZsh{} optimizer는 VQE 함수에서 스트링으로 옵션을 주게 되므로, 따로 만들지 않아도 괜찮다.}
    \PYG{n}{noiseless\PYGZus{}estimator} \PYG{o}{=} \PYG{n}{Estimator}\PYG{p}{(}\PYG{p}{)}
    \PYG{c+c1}{\PYGZsh{} 구버전인 Qiskit Primitive 에서 제공하는 Estimator를 정의 이때 backend도 같이 시뮬레이터로써 정의됨.}
    \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{:} \PYG{c+c1}{\PYGZsh{} 2개의 Ansatz 계산을 위한 for문}
        \PYG{n}{ansatz} \PYG{o}{=} \PYG{n}{ansatzs}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}
        \PYG{n}{ansatz\PYGZus{}name}\PYG{o}{=} \PYG{n}{ansatzs\PYGZus{}name}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}
        \PYG{n}{MAX\PYGZus{}ITER} \PYG{o}{=} \PYG{n+nb}{iter}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}
        \PYG{c+c1}{\PYGZsh{} i(0 또는 1)번째 Ansatz가 이번 for문에서 사용될 Ansatz임을 정의}
        \PYG{n}{opt\PYGZus{}arr} \PYG{o}{=} \PYG{p}{[}\PYG{n}{COBYLA}\PYG{p}{(}\PYG{n}{maxiter}\PYG{o}{=}\PYG{n}{MAX\PYGZus{}ITER}\PYG{p}{)}\PYG{p}{,}\PYG{n}{SPSA}\PYG{p}{(}\PYG{n}{maxiter}\PYG{o}{=}\PYG{n}{MAX\PYGZus{}ITER}\PYG{p}{)}\PYG{p}{,}\PYG{n}{L\PYGZus{}BFGS\PYGZus{}B}\PYG{p}{(}\PYG{n}{maxiter}\PYG{o}{=}\PYG{n}{MAX\PYGZus{}ITER}\PYG{p}{)}\PYG{p}{]}
        \PYG{c+c1}{\PYGZsh{} 3개의 optimizer 에 대한 리스트 생성}
        \PYG{k}{for} \PYG{n}{k} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{:} \PYG{c+c1}{\PYGZsh{} 3개의 optimizer 에 대한 계산을 위한 for문}
        \PYG{c+c1}{\PYGZsh{}즉, 이 밑의 계산이 총 6번 진행된다.}
            \PYG{n}{make\PYGZus{}intermediate\PYGZus{}info}\PYG{p}{(}\PYG{p}{)}
            \PYG{c+c1}{\PYGZsh{} callback 함수의 딕셔너리를 초기화}
            \PYG{n}{optimizer} \PYG{o}{=} \PYG{n}{opt\PYGZus{}arr}\PYG{p}{[}\PYG{n}{k}\PYG{p}{]}
            \PYG{n}{opt\PYGZus{}name} \PYG{o}{=} \PYG{n}{opt\PYGZus{}names}\PYG{p}{[}\PYG{n}{k}\PYG{p}{]}
            \PYG{c+c1}{\PYGZsh{} k(0,1 또는 2)번째 optimizer가 이번 for문에서 사용될 optimizer임을 정의}
            \PYG{n}{vqe} \PYG{o}{=} \PYG{n}{VQE}\PYG{p}{(}\PYG{n}{noiseless\PYGZus{}estimator}\PYG{p}{,} \PYG{n}{ansatz}\PYG{p}{,} \PYG{n}{optimizer}\PYG{p}{,} \PYG{n}{callback} \PYG{o}{=} \PYG{n}{callback}\PYG{p}{)}
            \PYG{c+c1}{\PYGZsh{} 초기에 실험했던 함수로써 Qiskit 에서 제공하는 VQE 함수를 사용}
            \PYG{c+c1}{\PYGZsh{} 위에서 정의한 변수들을 이용하여 VQE 계산을 정의}
            \PYG{n}{result} \PYG{o}{=} \PYG{n}{vqe}\PYG{o}{.}\PYG{n}{compute\PYGZus{}minimum\PYGZus{}eigenvalue}\PYG{p}{(}\PYG{n}{qubit\PYGZus{}op}\PYG{p}{)}
            \PYG{c+c1}{\PYGZsh{} vqe.compute\PYGZus{}minimum\PYGZus{}eigenvalue 함수를 통해 qubit\PYGZus{}op 라는 파울리 스트링으로 표현된 헤밀토니안에 대한 바닥상태 에너지를 계산.}
            \PYG{n}{vqe\PYGZus{}result} \PYG{o}{=} \PYG{n}{result}\PYG{o}{.}\PYG{n}{eigenvalue}\PYG{o}{.}\PYG{n}{real}
            \PYG{c+c1}{\PYGZsh{} 계산된 결과인 가장 작은 eigenvalue를 실수값으로 반환}
            \PYG{n}{core} \PYG{o}{=} \PYG{n}{as\PYGZus{}problem}\PYG{o}{.}\PYG{n}{hamiltonian}\PYG{o}{.}\PYG{n}{constants}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ActiveSpaceTransformer}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
            \PYG{c+c1}{\PYGZsh{} ActiveSpace 를 정의할때 core space로 무시한 오비탈 들에대한 에너지 계산 (상수)}
            \PYG{n}{repulsion} \PYG{o}{=} \PYG{n}{as\PYGZus{}problem}\PYG{o}{.}\PYG{n}{hamiltonian}\PYG{o}{.}\PYG{n}{constants}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{nuclear\PYGZus{}repulsion\PYGZus{}energy}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
            \PYG{c+c1}{\PYGZsh{} Born\PYGZhy{}oppenheimer 근사를 적용할때 상수로 처리되었던 핵간 척력을 계산 (상수)}

            \PYG{n}{exact\PYGZus{}energy} \PYG{o}{=} \PYG{n}{exact\PYGZus{}solver}\PYG{p}{(}\PYG{n}{qubit\PYGZus{}op}\PYG{p}{,} \PYG{n}{as\PYGZus{}problem}\PYG{p}{)}\PYG{o}{.}\PYG{n}{total\PYGZus{}energies}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{.}\PYG{n}{real}
            \PYG{c+c1}{\PYGZsh{} 헤밀토니안을 직접 대각화 하여 Exact한 결과를 계산}
            \PYG{n}{dimer\PYGZus{}energy} \PYG{o}{=} \PYG{n}{vqe\PYGZus{}result}\PYG{o}{+}\PYG{n}{repulsion} \PYG{o}{+} \PYG{n}{core}
            \PYG{c+c1}{\PYGZsh{} VQE 의 결과와 Core 오비탈의 에너지, 핵간 척력 에너지를 더하여 최종결과 계산}
            \PYG{n}{Co\PYGZus{}Li\PYGZus{}energy} \PYG{o}{=} \PYG{n}{dimer\PYGZus{}energy}
            \PYG{c+c1}{\PYGZsh{} 최종 계산결과를 Co\PYGZus{}Li\PYGZus{}energy 라는 새로운 변수로 저장 (의미없음. 이전 계산코드를 활용하면서 생긴 부분)}
            \PYG{n}{energy\PYGZus{}arr}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{Co\PYGZus{}Li\PYGZus{}energy}\PYG{p}{)}
            \PYG{c+c1}{\PYGZsh{} 이번 조합에서의 결과를 에너지 리스트에 저장.}
            \PYG{c+c1}{\PYGZsh{} 총 6개의 에너지가 저장될 것.}
            \PYG{n}{ansatz\PYGZus{}order}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{ansatz\PYGZus{}name}\PYG{p}{)}
            \PYG{n}{opt\PYGZus{}order}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{opt\PYGZus{}name}\PYG{p}{)}
            \PYG{c+c1}{\PYGZsh{} 그림 및, 해석을 위해 실제 계산에서 사용된 Ansatz와 optimizer의 이름을 순서대로 저장.}

            \PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n+nb}{range}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{intermediate\PYGZus{}info}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{energy }\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}\PYG{p}{,} \PYG{n}{intermediate\PYGZus{}info}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{energy }\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{+}\PYG{n}{repulsion} \PYG{o}{+} \PYG{n}{core} \PYG{p}{)}
            \PYG{c+c1}{\PYGZsh{} 최적화과정에서 callback으로 저장된 정보를 바탕으로 그래프를 Plot}
            \PYG{n}{plt}\PYG{o}{.}\PYG{n}{axhline}\PYG{p}{(}\PYG{n}{exact\PYGZus{}energy}\PYG{p}{,} \PYG{n}{color} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{linewidth} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{label} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{exact energy}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
            \PYG{c+c1}{\PYGZsh{} 수렴정도를 확인하기 위한 Exact한 값또한 Plot}
            \PYG{n}{plt}\PYG{o}{.}\PYG{n}{title}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+si}{\PYGZob{}0\PYGZcb{}}\PYG{l+s+s1}{,}\PYG{l+s+si}{\PYGZob{}1\PYGZcb{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{o}{.}\PYG{n}{format}\PYG{p}{(}\PYG{n}{ansatz\PYGZus{}name} \PYG{p}{,} \PYG{n}{opt\PYGZus{}name}\PYG{p}{)}\PYG{p}{)}
            \PYG{c+c1}{\PYGZsh{} 사용된 Ansatz 와 optimizer 를 이용해 제목을 정의}
            \PYG{n}{plt}\PYG{o}{.}\PYG{n}{xlabel}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{VQE Iterations}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
            \PYG{n}{plt}\PYG{o}{.}\PYG{n}{ylabel}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Energy}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
            \PYG{n}{plt}\PYG{o}{.}\PYG{n}{grid}\PYG{p}{(}\PYG{p}{)}
            \PYG{n}{plt}\PYG{o}{.}\PYG{n}{legend}\PYG{p}{(}\PYG{p}{)}
            \PYG{n}{plt}\PYG{o}{.}\PYG{n}{show}\PYG{p}{(}\PYG{p}{)}
            \PYG{c+c1}{\PYGZsh{} Iterations 그래프를 그려 각 조합별로 총 6개의 그림이 그려지게 된다.}

    \PYG{k}{return} \PYG{n}{energy\PYGZus{}arr}\PYG{p}{,} \PYG{n}{ansatz\PYGZus{}order}\PYG{p}{,} \PYG{n}{opt\PYGZus{}order}
    \PYG{c+c1}{\PYGZsh{} energy\PYGZus{}arr : 총 6개의 조합에서 계산된 6개의 에너지가 들어있는 리스트}
    \PYG{c+c1}{\PYGZsh{} ansatz\PYGZus{}order, opt\PYGZus{}order  : 계산된 Ansatz 와 optimizer의 순서대로 저장되어있는 리스트}
    \PYG{c+c1}{\PYGZsh{} 3가지의 리스트를 출력.}
\end{MintedVerbatim}
